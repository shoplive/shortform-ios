// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name ShopliveSDKCommon
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Accelerate
import CarPlay
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import Dispatch
import Foundation
import ImageIO
import MediaPlayer
import MobileCoreServices
import Photos
import QuartzCore
import Security
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import WebKit
import _Concurrency
import _StringProcessing
import zlib
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: ShopliveSDKCommon.URLRequestConvertible, with parameters: ShopliveSDKCommon.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : ShopliveSDKCommon.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: ShopliveSDKCommon.URLEncoding.Destination, b: ShopliveSDKCommon.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: ShopliveSDKCommon.URLEncoding.BoolEncoding, b: ShopliveSDKCommon.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: ShopliveSDKCommon.URLEncoding {
    get
  }
  public static var queryString: ShopliveSDKCommon.URLEncoding {
    get
  }
  public static var httpBody: ShopliveSDKCommon.URLEncoding {
    get
  }
  public let destination: ShopliveSDKCommon.URLEncoding.Destination
  public let arrayEncoding: ShopliveSDKCommon.URLEncoding.ArrayEncoding
  public let boolEncoding: ShopliveSDKCommon.URLEncoding.BoolEncoding
  public init(destination: ShopliveSDKCommon.URLEncoding.Destination = .methodDependent, arrayEncoding: ShopliveSDKCommon.URLEncoding.ArrayEncoding = .brackets, boolEncoding: ShopliveSDKCommon.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: ShopliveSDKCommon.URLRequestConvertible, with parameters: ShopliveSDKCommon.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : ShopliveSDKCommon.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: ShopliveSDKCommon.JSONEncoding.Error, b: ShopliveSDKCommon.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: ShopliveSDKCommon.JSONEncoding {
    get
  }
  public static var prettyPrinted: ShopliveSDKCommon.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: ShopliveSDKCommon.URLRequestConvertible, with parameters: ShopliveSDKCommon.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: ShopliveSDKCommon.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
extension ShopliveSDKCommon.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public enum ImageFormat {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: ShopliveSDKCommon.ImageFormat, b: ShopliveSDKCommon.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : ShopliveSDKCommon.SLKingfisherCompatibleValue {
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: ShopliveSDKCommon.ImageFormat {
    get
  }
  public func contains(jpeg marker: ShopliveSDKCommon.ImageFormat.JPEGMarker) -> Swift.Bool
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func loadImage(from url: Foundation.URL?, placeHolderImage: UIKit.UIImage? = nil, completion: ((UIKit.UIImage?) -> ())? = nil)
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : ShopliveSDKCommon.DataResponseSerializerProtocol, ShopliveSDKCommon.DownloadResponseSerializerProtocol {
  var dataPreprocessor: ShopliveSDKCommon.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : ShopliveSDKCommon.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : ShopliveSDKCommon.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension ShopliveSDKCommon.DataPreprocessor where Self == ShopliveSDKCommon.PassthroughPreprocessor {
  public static var passthrough: ShopliveSDKCommon.PassthroughPreprocessor {
    get
  }
}
extension ShopliveSDKCommon.DataPreprocessor where Self == ShopliveSDKCommon.GoogleXSSIPreprocessor {
  public static var googleXSSI: ShopliveSDKCommon.GoogleXSSIPreprocessor {
    get
  }
}
extension ShopliveSDKCommon.ResponseSerializer {
  public static var defaultDataPreprocessor: ShopliveSDKCommon.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: ShopliveSDKCommon.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension ShopliveSDKCommon.DownloadResponseSerializerProtocol where Self : ShopliveSDKCommon.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension ShopliveSDKCommon.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : ShopliveSDKCommon.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : ShopliveSDKCommon.ResponseSerializer
}
extension ShopliveSDKCommon.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : ShopliveSDKCommon.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : ShopliveSDKCommon.ResponseSerializer
}
public struct URLResponseSerializer : ShopliveSDKCommon.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension ShopliveSDKCommon.DownloadResponseSerializerProtocol where Self == ShopliveSDKCommon.URLResponseSerializer {
  public static var url: ShopliveSDKCommon.URLResponseSerializer {
    get
  }
}
extension ShopliveSDKCommon.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : ShopliveSDKCommon.ResponseSerializer {
  final public let dataPreprocessor: ShopliveSDKCommon.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  public init(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension ShopliveSDKCommon.ResponseSerializer where Self == ShopliveSDKCommon.DataResponseSerializer {
  public static var data: ShopliveSDKCommon.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataResponseSerializer
}
extension ShopliveSDKCommon.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : ShopliveSDKCommon.ResponseSerializer {
  final public let dataPreprocessor: ShopliveSDKCommon.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  public init(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension ShopliveSDKCommon.ResponseSerializer where Self == ShopliveSDKCommon.StringResponseSerializer {
  public static var string: ShopliveSDKCommon.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.StringResponseSerializer
}
extension ShopliveSDKCommon.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : ShopliveSDKCommon.ResponseSerializer {
  final public let dataPreprocessor: ShopliveSDKCommon.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension ShopliveSDKCommon.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: ShopliveSDKCommon.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension ShopliveSDKCommon.Empty : ShopliveSDKCommon.EmptyResponse {
  public static func emptyValue() -> ShopliveSDKCommon.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : ShopliveSDKCommon.DataDecoder {
}
extension Foundation.PropertyListDecoder : ShopliveSDKCommon.DataDecoder {
}
final public class DecodableResponseSerializer<T> : ShopliveSDKCommon.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: ShopliveSDKCommon.DataPreprocessor
  final public let decoder: ShopliveSDKCommon.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  public init(dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension ShopliveSDKCommon.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DecodableResponseSerializer<T> where Self == ShopliveSDKCommon.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension ShopliveSDKCommon.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension ShopliveSDKCommon.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (ShopliveSDKCommon.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : ShopliveSDKCommon.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: ShopliveSDKCommon.DataDecoder
  public let dataPreprocessor: ShopliveSDKCommon.DataPreprocessor
  public init(decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : ShopliveSDKCommon.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : ShopliveSDKCommon.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension ShopliveSDKCommon.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == ShopliveSDKCommon.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension ShopliveSDKCommon.DataStreamSerializer where Self == ShopliveSDKCommon.PassthroughStreamSerializer {
  public static var passthrough: ShopliveSDKCommon.PassthroughStreamSerializer {
    get
  }
}
extension ShopliveSDKCommon.DataStreamSerializer where Self == ShopliveSDKCommon.StringStreamSerializer {
  public static var string: ShopliveSDKCommon.StringStreamSerializer {
    get
  }
}
extension ShopliveSDKCommon.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping ShopliveSDKCommon.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping ShopliveSDKCommon.DataStreamRequest.Handler<Serializer.SerializedObject, ShopliveSDKCommon.AFError>) -> Self where Serializer : ShopliveSDKCommon.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping ShopliveSDKCommon.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), preprocessor: ShopliveSDKCommon.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping ShopliveSDKCommon.DataStreamRequest.Handler<T, ShopliveSDKCommon.AFError>) -> Self where T : Swift.Decodable
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func image(withRadius radius: ShopliveSDKCommon.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: ShopliveSDKCommon.RectCorner = .all, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: ShopliveSDKCommon.RectCorner = .all, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: ShopliveSDKCommon.ContentMode) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func addingBorder(_ border: ShopliveSDKCommon.Border) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func overlaying(with color: ShopliveSDKCommon.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func tinted(with color: ShopliveSDKCommon.KFCrossPlatformColor) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: ShopliveSDKCommon.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public struct AVAssetImageDataProvider : ShopliveSDKCommon.ImageDataProvider {
  public enum AVAssetImageDataProviderError : Swift.Error {
    case userCancelled
    case invalidImage(_: CoreGraphics.CGImage?)
  }
  public let assetImageGenerator: AVFoundation.AVAssetImageGenerator
  public let time: CoreMedia.CMTime
  public var cacheKey: Swift.String {
    get
  }
  public init(assetImageGenerator: AVFoundation.AVAssetImageGenerator, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, time: CoreMedia.CMTime)
  public init(assetURL: Foundation.URL, seconds: Foundation.TimeInterval)
  public func data(handler: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addArrangedSubviews(_ views: UIKit.UIView...)
}
public enum SLReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let SLReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class SLReachability {
  public typealias NetworkReachable = (ShopliveSDKCommon.SLReachability) -> ()
  public typealias NetworkUnreachable = (ShopliveSDKCommon.SLReachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: ShopliveSDKCommon.SLReachability.NetworkStatus, b: ShopliveSDKCommon.SLReachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: ShopliveSDKCommon.SLReachability.Connection
    public static func == (a: ShopliveSDKCommon.SLReachability.Connection, b: ShopliveSDKCommon.SLReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: ShopliveSDKCommon.SLReachability.NetworkReachable?
  public var whenUnreachable: ShopliveSDKCommon.SLReachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: ShopliveSDKCommon.SLReachability.Connection {
    get
  }
  public var connection: ShopliveSDKCommon.SLReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension ShopliveSDKCommon.SLReachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class SLBaseView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func layout()
  @_Concurrency.MainActor(unsafe) open func attributes()
  @_Concurrency.MainActor(unsafe) open func bindView()
  @_Concurrency.MainActor(unsafe) open func bindData()
  @_Concurrency.MainActor(unsafe) open var touchEventHandler: ((Swift.Set<UIKit.UITouch>, UIKit.UIEvent?) -> ())?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc deinit
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : ShopliveSDKCommon.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: ShopliveSDKCommon.AuthenticationError, b: ShopliveSDKCommon.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : ShopliveSDKCommon.RequestInterceptor where AuthenticatorType : ShopliveSDKCommon.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: ShopliveSDKCommon.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: ShopliveSDKCommon.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: ShopliveSDKCommon.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  @objc deinit
}
extension Swift.Int {
  public func addCommas() -> Swift.String
  public var toJsonValue: Swift.String {
    get
  }
}
extension ShopliveSDKCommon.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension ShopliveSDKCommon.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> ShopliveSDKCommon.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension ShopliveSDKCommon.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> ShopliveSDKCommon.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension ShopliveSDKCommon.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> ShopliveSDKCommon.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func transition(with window: UIKit.UIWindow)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func shopliveHideKeyboard()
  @_Concurrency.MainActor(unsafe) public func hideKeyboard()
  @_Concurrency.MainActor(unsafe) public func showShareSheet(url: Swift.String?)
}
extension Swift.String : ShopliveSDKCommon.SLKingfisherCompatibleValue {
}
public enum SLToastDuration {
  case short
  case middle
  case long
  public static func == (a: ShopliveSDKCommon.SLToastDuration, b: ShopliveSDKCommon.SLToastDuration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func showToastAlert(messgae: Swift.String)
  @_Concurrency.MainActor(unsafe) public func showToast(message: Swift.String, duration: ShopliveSDKCommon.SLToastDuration = .middle)
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) public func showToast(message: Swift.String, duration: ShopliveSDKCommon.SLToastDuration = .middle)
}
extension UIKit.UIInterfaceOrientation {
  public var angle: CoreFoundation.CGFloat {
    get
  }
  public var deviceOrientation: UIKit.UIDeviceOrientation {
    get
  }
}
public enum ShopliveErrorType : Swift.Int, Swift.CaseIterable {
  case NO_IDLE_STREAM_SERVER
  case BAD_GATEWAY
  case UNAUTHORIZED
  case EXCEPTION
  case MODULE_ERROR
  case TIMEOUT
  case NO_INTERNET_CONNECTION
  case NO_NETWORK_CONNECTION
  case NO_DATA_NETWORK
  case BAD_RESPONSE
  case UPDATE_PASSWORD
  case LIMIT_TRY_CHECK_PASSWORD
  case WRONG_PASSWORD
  case NOT_EXIST_ACCOUNT
  case NOT_VALID_ID_PASSWORD
  case FORCE_UPDATE
  case UPGRADE_REQUIRED
  case UNSUPPORTED_VERSION
  case STREAM_SERVER_NO_RESPONSE
  case DUPLICATE_STREAM_KEY
  case CAMPAIGN_NOT_FOUND
  case CAMPAIGN_CLOSED
  case CLIENT_IP_BLOCK
  case STREAM_REMAINED
  case DUPLICATE_STREAM_KEY_MANUAL
  public var convertedToError: Swift.Error {
    get
  }
  public var code: Swift.Int {
    get
  }
  public var domain: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [ShopliveSDKCommon.ShopliveErrorType]
  public typealias RawValue = Swift.Int
  public static var allCases: [ShopliveSDKCommon.ShopliveErrorType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public typealias SLKingfisherOptionsInfo = [ShopliveSDKCommon.SLKingfisherOptionsInfoItem]
public enum SLKingfisherOptionsInfoItem {
  case targetCache(ShopliveSDKCommon.ImageCache)
  case originalCache(ShopliveSDKCommon.ImageCache)
  case downloader(ShopliveSDKCommon.ImageDownloader)
  case transition(ShopliveSDKCommon.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(ShopliveSDKCommon.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(ShopliveSDKCommon.AsyncImageDownloadRequestModifier)
  case redirectHandler(ShopliveSDKCommon.ImageDownloadRedirectHandler)
  case processor(ShopliveSDKCommon.ImageProcessor)
  case cacheSerializer(ShopliveSDKCommon.CacheSerializer)
  case imageModifier(ShopliveSDKCommon.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(ShopliveSDKCommon.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(ShopliveSDKCommon.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(ShopliveSDKCommon.ExpirationExtending)
  case diskCacheExpiration(ShopliveSDKCommon.StorageExpiration)
  case diskCacheAccessExtendingExpiration(ShopliveSDKCommon.ExpirationExtending)
  case processingQueue(ShopliveSDKCommon.CallbackQueue)
  case progressiveJPEG(ShopliveSDKCommon.ImageProgressive)
  case alternativeSources([ShopliveSDKCommon.Source])
  case retryStrategy(ShopliveSDKCommon.RetryStrategy)
  case lowDataMode(ShopliveSDKCommon.Source?)
}
public struct SLKingfisherParsedOptionsInfo {
  public var targetCache: ShopliveSDKCommon.ImageCache?
  public var originalCache: ShopliveSDKCommon.ImageCache?
  public var downloader: ShopliveSDKCommon.ImageDownloader?
  public var transition: ShopliveSDKCommon.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: ShopliveSDKCommon.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: ShopliveSDKCommon.AsyncImageDownloadRequestModifier?
  public var redirectHandler: ShopliveSDKCommon.ImageDownloadRedirectHandler?
  public var processor: ShopliveSDKCommon.ImageProcessor
  public var imageModifier: ShopliveSDKCommon.ImageModifier?
  public var cacheSerializer: ShopliveSDKCommon.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: ShopliveSDKCommon.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: ShopliveSDKCommon.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: ShopliveSDKCommon.ExpirationExtending
  public var diskCacheExpiration: ShopliveSDKCommon.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: ShopliveSDKCommon.ExpirationExtending
  public var processingQueue: ShopliveSDKCommon.CallbackQueue?
  public var progressiveJPEG: ShopliveSDKCommon.ImageProgressive?
  public var alternativeSources: [ShopliveSDKCommon.Source]?
  public var retryStrategy: ShopliveSDKCommon.RetryStrategy?
  public var lowDataModeSource: ShopliveSDKCommon.Source?
  public init(_ info: ShopliveSDKCommon.SLKingfisherOptionsInfo?)
}
extension UIKit.UIImage {
  public func resizeWithWidth(width: CoreFoundation.CGFloat) -> UIKit.UIImage?
  public func imageWithTint(_ color: UIKit.UIColor, alpha: CoreFoundation.CGFloat = 1.0) -> UIKit.UIImage
  public func resizeImageTo(size: CoreFoundation.CGSize) -> UIKit.UIImage?
  public func scalePreservingAspectRatio(targetSize: CoreFoundation.CGSize) -> UIKit.UIImage
  public func changeScale(to: CoreFoundation.CGFloat) -> UIKit.UIImage?
  public func resizeWith(width: CoreFoundation.CGFloat) -> UIKit.UIImage?
  public func toBlackAndWhite() -> UIKit.UIImage?
  public enum Quality {
    case uncompressed
    case highest
    case high
    case medium
    case low
    case lowest
    public static func == (a: UIKit.UIImage.Quality, b: UIKit.UIImage.Quality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var uncompressedPNGData: Foundation.Data? {
    get
  }
  public var highestQualityJPEGNSData: Foundation.Data? {
    get
  }
  public var highQualityJPEGNSData: Foundation.Data? {
    get
  }
  public var mediumQualityJPEGNSData: Foundation.Data? {
    get
  }
  public var lowQualityJPEGNSData: Foundation.Data? {
    get
  }
  public var lowestQualityJPEGNSData: Foundation.Data? {
    get
  }
  public func toNSTextAttachment(_ width: CoreFoundation.CGFloat? = nil, _ height: CoreFoundation.CGFloat? = nil, _ yPos: CoreFoundation.CGFloat = -8) -> UIKit.NSTextAttachment
  public func toNSTextAttachment(yPos: CoreFoundation.CGFloat = -8) -> UIKit.NSTextAttachment
  convenience public init?(color: UIKit.UIColor, size: CoreFoundation.CGSize = CGSize(width: 1, height: 1))
}
extension Swift.Dictionary {
  public func toJson() -> Swift.String?
  public var jsonData: Foundation.Data? {
    get
  }
  public func toJSONString() -> Swift.String?
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func fit()
  @_Concurrency.MainActor(unsafe) public func fitTop30()
  @_Concurrency.MainActor(unsafe) public func animateSizeChange(from: CoreFoundation.CGSize, to: CoreFoundation.CGSize, duration: Swift.Double)
  @_Concurrency.MainActor(unsafe) public func changeScale(to: CoreFoundation.CGFloat)
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var cornerRadiusV: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var borderWidthV: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) dynamic public var borderColorV: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var ratio: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var showsUp: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var parentViewController: UIKit.UIViewController? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func addAndFitToParent(view: UIKit.UIView, belowSubview: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func fitToParent()
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func asImage() -> UIKit.UIImage
  @_Concurrency.MainActor(unsafe) public class func fromNib<T>() -> T where T : UIKit.UIView
  @_Concurrency.MainActor(unsafe) public func makeDashedBorderLine(lineDashWidth: CoreFoundation.CGFloat, pattern: [Foundation.NSNumber])
  @discardableResult
  @_Concurrency.MainActor(unsafe) public func setGradientBackground(bottom: UIKit.UIColor = UIColor.black.withAlphaComponent(0.5), top: UIKit.UIColor = UIColor.clear) -> QuartzCore.CAGradientLayer
  @_Concurrency.MainActor(unsafe) public func removeGradientBackground()
  @_Concurrency.MainActor(unsafe) public func constrainCentered(_ subview: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func constrainToEdges(_ subview: UIKit.UIView)
  @_Concurrency.MainActor(unsafe) public func addBlurEffect()
  @_Concurrency.MainActor(unsafe) public func addSubviews(_ views: UIKit.UIView...)
  @_Concurrency.MainActor(unsafe) public var globalPoint: CoreFoundation.CGPoint? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var globalFrame: CoreFoundation.CGRect? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func snapshot(afterScreenUpdates: Swift.Bool = false, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func fitToSuperView()
  public enum ViewSide {
    case Left, Right, Top, Bottom
    public static func == (a: UIKit.UIView.ViewSide, b: UIKit.UIView.ViewSide) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public func addBorder(toSide side: UIKit.UIView.ViewSide, withColor color: CoreGraphics.CGColor, andThickness thickness: CoreFoundation.CGFloat)
}
public typealias DownloadProgressBlock = ((_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult {
  public let image: ShopliveSDKCommon.KFCrossPlatformImage
  public let cacheType: ShopliveSDKCommon.CacheType
  public let source: ShopliveSDKCommon.Source
  public let originalSource: ShopliveSDKCommon.Source
  public let data: () -> Foundation.Data?
}
public struct PropagationError {
  public let source: ShopliveSDKCommon.Source
  public let error: ShopliveSDKCommon.SLKingfisherError
}
public typealias SLDownloadTaskUpdatedBlock = ((_ newTask: ShopliveSDKCommon.SLDownloadTask?) -> Swift.Void)
public class SLKingfisherManager {
  public static let shared: ShopliveSDKCommon.SLKingfisherManager
  public var cache: ShopliveSDKCommon.ImageCache
  public var downloader: ShopliveSDKCommon.ImageDownloader
  public var defaultOptions: ShopliveSDKCommon.SLKingfisherOptionsInfo
  public init(downloader: ShopliveSDKCommon.ImageDownloader, cache: ShopliveSDKCommon.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: ShopliveSDKCommon.Resource, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, downloadTaskUpdated: ShopliveSDKCommon.SLDownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)?) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func retrieveImage(with source: ShopliveSDKCommon.Source, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, downloadTaskUpdated: ShopliveSDKCommon.SLDownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)?) -> ShopliveSDKCommon.SLDownloadTask?
  @objc deinit
}
extension CoreFoundation.CGSize : ShopliveSDKCommon.SLKingfisherCompatibleValue {
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: ShopliveSDKCommon.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
@_hasMissingDesignatedInitializers final public class ShopliveCommon {
  public enum Request {
    case setBaseURL(closure: (ShopliveSDKCommon.HTTPVersion) -> Swift.String)
    case setAccessToken(Swift.String)
    case setGuestUid(Swift.String)
    case setAdId(Swift.String)
  }
  public static let shared: ShopliveSDKCommon.ShopliveCommon
  final public func request(_ request: ShopliveSDKCommon.ShopliveCommon.Request)
  final public var accessToken: Swift.String?
  final public var guestUid: Swift.String?
  final public var adId: Swift.String?
  @objc deinit
}
extension ShopliveSDKCommon.ShopliveCommon {
  final public var sdkVersion: Swift.String {
    get
  }
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: Swift.Error?)
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload data: Foundation.Data, with dataTask: ShopliveSDKCommon.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload image: ShopliveSDKCommon.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: ShopliveSDKCommon.ImageDownloader) -> Swift.Bool
  func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
extension ShopliveSDKCommon.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: Swift.Error?)
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload image: ShopliveSDKCommon.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: ShopliveSDKCommon.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload data: Foundation.Data, with task: ShopliveSDKCommon.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  public func imageDownloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension ShopliveSDKCommon.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var childForStatusBarStyle: UIKit.UIViewController? {
    @objc get
  }
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: ShopliveSDKCommon.Redirector
  public static let doNotFollow: ShopliveSDKCommon.Redirector
  public let behavior: ShopliveSDKCommon.Redirector.Behavior
  public init(behavior: ShopliveSDKCommon.Redirector.Behavior)
}
extension ShopliveSDKCommon.Redirector : ShopliveSDKCommon.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension ShopliveSDKCommon.RedirectHandler where Self == ShopliveSDKCommon.Redirector {
  public static var follow: ShopliveSDKCommon.Redirector {
    get
  }
  public static var doNotFollow: ShopliveSDKCommon.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> ShopliveSDKCommon.Redirector
}
public protocol CacheSerializer {
  func data(with image: ShopliveSDKCommon.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
  var originalDataUsed: Swift.Bool { get }
}
extension ShopliveSDKCommon.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : ShopliveSDKCommon.CacheSerializer {
  public static let `default`: ShopliveSDKCommon.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  public func data(with image: ShopliveSDKCommon.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public protocol AnimatedImageViewDelegate : AnyObject {
  func animatedImageView(_ imageView: ShopliveSDKCommon.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  func animatedImageViewDidFinishAnimating(_ imageView: ShopliveSDKCommon.AnimatedImageView)
}
extension ShopliveSDKCommon.AnimatedImageViewDelegate {
  public func animatedImageView(_ imageView: ShopliveSDKCommon.AnimatedImageView, didPlayAnimationLoops count: Swift.UInt)
  public func animatedImageViewDidFinishAnimating(_ imageView: ShopliveSDKCommon.AnimatedImageView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedImageView : UIKit.UIImageView {
  public enum RepeatCount : Swift.Equatable {
    case once
    case finite(count: Swift.UInt)
    case infinite
    public static func == (lhs: ShopliveSDKCommon.AnimatedImageView.RepeatCount, rhs: ShopliveSDKCommon.AnimatedImageView.RepeatCount) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) public var autoPlayAnimatedImage: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var framePreloadCount: Swift.Int
  @_Concurrency.MainActor(unsafe) public var needsPrescaling: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var backgroundDecode: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var runLoopMode: Foundation.RunLoop.Mode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var repeatCount: ShopliveSDKCommon.AnimatedImageView.RepeatCount {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak public var delegate: ShopliveSDKCommon.AnimatedImageViewDelegate?
  @_Concurrency.MainActor(unsafe) public var animator: ShopliveSDKCommon.AnimatedImageView.Animator? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var image: ShopliveSDKCommon.KFCrossPlatformImage? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isAnimating: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func startAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func stopAnimating()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func display(_ layer: QuartzCore.CALayer)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension ShopliveSDKCommon.AnimatedImageView {
  @_hasMissingDesignatedInitializers public class Animator {
    final public let maxFrameCount: Swift.Int
    public var currentFrameImage: UIKit.UIImage? {
      get
    }
    public var currentFrameDuration: Foundation.TimeInterval {
      get
    }
    public var currentFrameIndex: Swift.Int {
      get
    }
    public var isLastFrame: Swift.Bool {
      get
    }
    @objc deinit
    public func frame(at index: Swift.Int) -> ShopliveSDKCommon.KFCrossPlatformImage?
    public func duration(at index: Swift.Int) -> Foundation.TimeInterval
  }
}
@available(*, deprecated)
final public class ActivityData {
  public init(size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, messageSpacing: CoreFoundation.CGFloat? = nil, type: ShopliveSDKCommon.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(*, deprecated)
final public class NVActivityIndicatorPresenter {
  public static let sharedInstance: ShopliveSDKCommon.NVActivityIndicatorPresenter
  final public var isAnimating: Swift.Bool {
    get
  }
  final public func startAnimating(_ data: ShopliveSDKCommon.ActivityData, _ fadeInAnimation: ShopliveSDKCommon.FadeInAnimation? = nil)
  final public func stopAnimating(_ fadeOutAnimation: ShopliveSDKCommon.FadeOutAnimation? = nil)
  final public func setMessage(_ message: Swift.String?)
  @objc deinit
}
@available(*, deprecated)
public protocol SLSLNVActivityIndicatorViewable {
}
@available(*, deprecated)
extension ShopliveSDKCommon.SLSLNVActivityIndicatorViewable where Self : UIKit.UIViewController {
  public var isAnimating: Swift.Bool {
    get
  }
  public func startAnimating(_ size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, type: ShopliveSDKCommon.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, fadeInAnimation: ShopliveSDKCommon.FadeInAnimation? = SLSLNVActivityIndicatorView.DEFAULT_FADE_IN_ANIMATION)
  public func stopAnimating(_ fadeOutAnimation: ShopliveSDKCommon.FadeOutAnimation? = SLSLNVActivityIndicatorView.DEFAULT_FADE_OUT_ANIMATION)
}
@objc public protocol SLLoadingAlertControllerDelegate {
  @objc func cancelLoading()
  @objc func finishLoading()
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SLLoadingAlertController : UIKit.UIViewController, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) weak public var delegate: ShopliveSDKCommon.SLLoadingAlertControllerDelegate?
  @_Concurrency.MainActor(unsafe) public var cancelLoading: Swift.Bool
  @_Concurrency.MainActor(unsafe) public func setLoadingText(_ text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) public func finishLoading()
  @_Concurrency.MainActor(unsafe) public func cancal()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(ShopliveSDKCommon.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: ShopliveSDKCommon.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: ShopliveSDKCommon.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: ShopliveSDKCommon.AFError.ServerTrustFailureReason.Output, options: ShopliveSDKCommon.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: ShopliveSDKCommon.URLConvertible)
  case multipartEncodingFailed(reason: ShopliveSDKCommon.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: ShopliveSDKCommon.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: ShopliveSDKCommon.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: ShopliveSDKCommon.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: ShopliveSDKCommon.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: ShopliveSDKCommon.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: ShopliveSDKCommon.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: ShopliveSDKCommon.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> ShopliveSDKCommon.AFError
}
extension ShopliveSDKCommon.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension ShopliveSDKCommon.AFError {
  public var urlConvertible: ShopliveSDKCommon.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension ShopliveSDKCommon.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class SLKeyChainUtil {
  public static func save(keychainData: ShopliveSDKCommon.KeychainData, value: Swift.String)
  public static func save(service: Swift.String, account: Swift.String, value: Swift.String)
  public static func load(keychainData: ShopliveSDKCommon.KeychainData) -> Swift.String?
  public static func load(service: Swift.String, account: Swift.String) -> Swift.String?
  public static func delete(service: Swift.String, account: Swift.String)
  public static func resetKeychain()
  @objc deinit
}
public enum Strings {
  public enum Error {
    public enum Msg {
      public static let base: Swift.String
      public static let empty: Swift.String
      public static let login: Swift.String
      public static let noInternet: Swift.String
      public enum Server {
        public static let timeout: Swift.String
        public static let unknown: Swift.String
      }
    }
  }
}
extension Swift.Double {
  public var seconds: Swift.Double {
    get
  }
  public var isValid: Swift.Bool {
    get
  }
  public var timeHourMinuteSeconds: Swift.String {
    get
  }
}
public protocol AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  var onDownloadTaskStarted: ((ShopliveSDKCommon.SLDownloadTask?) -> Swift.Void)? { get }
}
public protocol ImageDownloadRequestModifier : ShopliveSDKCommon.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension ShopliveSDKCommon.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public var onDownloadTaskStarted: ((ShopliveSDKCommon.SLDownloadTask?) -> Swift.Void)? {
    get
  }
}
public struct AnyModifier : ShopliveSDKCommon.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest) -> Foundation.URLRequest?)
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> where T : ShopliveSDKCommon.DataTransformable {
    public var config: ShopliveSDKCommon.DiskStorage.Config
    final public let directoryURL: Foundation.URL
    convenience public init(config: ShopliveSDKCommon.DiskStorage.Config) throws
    public func store(value: T, forKey key: Swift.String, expiration: ShopliveSDKCommon.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = []) throws
    public func value(forKey key: Swift.String, extendingExpiration: ShopliveSDKCommon.ExpirationExtending = .cacheTime) throws -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date) -> Swift.Bool
    public func remove(forKey key: Swift.String) throws
    public func removeAll() throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension ShopliveSDKCommon.DiskStorage {
  public struct Config {
    public var sizeLimit: Swift.UInt
    public var expiration: ShopliveSDKCommon.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: ((_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
extension Swift.Error {
  public var errorCode: Swift.Int {
    get
  }
  public func getErrorMsg() -> Swift.String
  public var userInfoString: Swift.String {
    get
  }
}
public struct CommonKeys {
  public static let Authorization: Swift.String
  public static let Content_Type: Swift.String
  public static let application_x_www_form_urlencdoed: Swift.String
  public static let x_sl_ebay_username: Swift.String
  public static let x_sl_studio_os_version: Swift.String
  public static let x_sl_studio_app_version: Swift.String
  public static let x_sl_studio_sdk_version: Swift.String
  public static let x_sl_guest_uid: Swift.String
  public static let x_sl_ad_id: Swift.String
  public static let Bearer: Swift.String
  public static let code: Swift.String
  public static let ON_CHANGED_VIDEO_EXPANDED: Swift.String
  public static let SET_VIDEO_POSITION: Swift.String
  public static let videoExpanded: Swift.String
  public static let endCampaign: Swift.String
  public static let startCampaign: Swift.String
  public static let rehearsal: Swift.String
  public static let keyword: Swift.String
  public static let deviceUuid: Swift.String
  public static let retry: Swift.String
  public static let resolution: Swift.String
  public static let bitRate: Swift.String
  public static let normal: Swift.String
  public static let description: Swift.String
  public static let currentFPS: Swift.String
  public static let customerId: Swift.String
  public static let page: Swift.String
  public static let count: Swift.String
  public static let height: Swift.String
  public static let width: Swift.String
  public static let centerCrop: Swift.String
  public static let x: Swift.String
  public static let y: Swift.String
  public static let pushType: Swift.String
  public static let campaignId: Swift.String
  public static let campaignStatus: Swift.String
  public static let id: Swift.String
  public static let password: Swift.String
  public static let streamApp: Swift.String
  public static let source: Swift.String
  public static let duration: Swift.String
}
public enum SLKingfisherError : Swift.Error {
  public enum RequestErrorReason {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: ShopliveSDKCommon.SessionDataTask, token: ShopliveSDKCommon.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: Swift.Error)
    case dataModifyingFailed(task: ShopliveSDKCommon.SessionDataTask)
    case noURLResponse(task: ShopliveSDKCommon.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: Swift.Error)
    case cannotSerializeImage(image: ShopliveSDKCommon.KFCrossPlatformImage?, original: Foundation.Data?, serializer: ShopliveSDKCommon.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
  }
  public enum ProcessorErrorReason {
    case processingFailed(processor: ShopliveSDKCommon.ImageProcessor, item: ShopliveSDKCommon.ImageProcessItem)
  }
  public enum ImageSettingErrorReason {
    case emptySource
    case notCurrentSourceTask(result: ShopliveSDKCommon.RetrieveImageResult?, error: Swift.Error?, source: ShopliveSDKCommon.Source)
    case dataProviderError(provider: ShopliveSDKCommon.ImageDataProvider, error: Swift.Error)
    case alternativeSourcesExhausted([ShopliveSDKCommon.PropagationError])
  }
  case requestError(reason: ShopliveSDKCommon.SLKingfisherError.RequestErrorReason)
  case responseError(reason: ShopliveSDKCommon.SLKingfisherError.ResponseErrorReason)
  case cacheError(reason: ShopliveSDKCommon.SLKingfisherError.CacheErrorReason)
  case processorError(reason: ShopliveSDKCommon.SLKingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: ShopliveSDKCommon.SLKingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension ShopliveSDKCommon.SLKingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ShopliveSDKCommon.SLKingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
@objc open class AFSessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension ShopliveSDKCommon.AFSessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension ShopliveSDKCommon.AFSessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension ShopliveSDKCommon.AFSessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension ShopliveSDKCommon.AFSessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public protocol ImageDataProvider {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension ShopliveSDKCommon.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> ShopliveSDKCommon.Source
}
public struct LocalFileImageDataProvider : ShopliveSDKCommon.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: ShopliveSDKCommon.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  public var data: Foundation.Data {
    get async throws
  }
  #endif
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : ShopliveSDKCommon.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : ShopliveSDKCommon.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: ShopliveSDKCommon.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: ShopliveSDKCommon.Request, didFailToCreateURLRequestWithError error: ShopliveSDKCommon.AFError)
  func request(_ request: ShopliveSDKCommon.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: ShopliveSDKCommon.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: ShopliveSDKCommon.AFError)
  func request(_ request: ShopliveSDKCommon.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: ShopliveSDKCommon.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: ShopliveSDKCommon.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: ShopliveSDKCommon.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: ShopliveSDKCommon.AFError)
  func request(_ request: ShopliveSDKCommon.Request, didCompleteTask task: Foundation.URLSessionTask, with error: ShopliveSDKCommon.AFError?)
  func requestIsRetrying(_ request: ShopliveSDKCommon.Request)
  func requestDidFinish(_ request: ShopliveSDKCommon.Request)
  func requestDidResume(_ request: ShopliveSDKCommon.Request)
  func request(_ request: ShopliveSDKCommon.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: ShopliveSDKCommon.Request)
  func request(_ request: ShopliveSDKCommon.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: ShopliveSDKCommon.Request)
  func request(_ request: ShopliveSDKCommon.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: ShopliveSDKCommon.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  func request(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Foundation.Data?, ShopliveSDKCommon.AFError>)
  func request<Value>(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError>)
  func request(_ request: ShopliveSDKCommon.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  func request<Value>(_ request: ShopliveSDKCommon.DataStreamRequest, didParseStream result: Swift.Result<Value, ShopliveSDKCommon.AFError>)
  func request(_ request: ShopliveSDKCommon.UploadRequest, didCreateUploadable uploadable: ShopliveSDKCommon.UploadRequest.Uploadable)
  func request(_ request: ShopliveSDKCommon.UploadRequest, didFailToCreateUploadableWithError error: ShopliveSDKCommon.AFError)
  func request(_ request: ShopliveSDKCommon.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: ShopliveSDKCommon.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, ShopliveSDKCommon.AFError>)
  func request(_ request: ShopliveSDKCommon.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: ShopliveSDKCommon.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  func request(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Foundation.URL?, ShopliveSDKCommon.AFError>)
  func request<Value>(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError>)
}
extension ShopliveSDKCommon.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: ShopliveSDKCommon.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: ShopliveSDKCommon.Request, didFailToCreateURLRequestWithError error: ShopliveSDKCommon.AFError)
  public func request(_ request: ShopliveSDKCommon.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: ShopliveSDKCommon.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: ShopliveSDKCommon.AFError)
  public func request(_ request: ShopliveSDKCommon.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: ShopliveSDKCommon.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: ShopliveSDKCommon.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: ShopliveSDKCommon.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: ShopliveSDKCommon.AFError)
  public func request(_ request: ShopliveSDKCommon.Request, didCompleteTask task: Foundation.URLSessionTask, with error: ShopliveSDKCommon.AFError?)
  public func requestIsRetrying(_ request: ShopliveSDKCommon.Request)
  public func requestDidFinish(_ request: ShopliveSDKCommon.Request)
  public func requestDidResume(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: ShopliveSDKCommon.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  public func request(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Foundation.Data?, ShopliveSDKCommon.AFError>)
  public func request<Value>(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError>)
  public func request(_ request: ShopliveSDKCommon.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  public func request<Value>(_ request: ShopliveSDKCommon.DataStreamRequest, didParseStream result: Swift.Result<Value, ShopliveSDKCommon.AFError>)
  public func request(_ request: ShopliveSDKCommon.UploadRequest, didCreateUploadable uploadable: ShopliveSDKCommon.UploadRequest.Uploadable)
  public func request(_ request: ShopliveSDKCommon.UploadRequest, didFailToCreateUploadableWithError error: ShopliveSDKCommon.AFError)
  public func request(_ request: ShopliveSDKCommon.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: ShopliveSDKCommon.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, ShopliveSDKCommon.AFError>)
  public func request(_ request: ShopliveSDKCommon.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: ShopliveSDKCommon.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  public func request(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Foundation.URL?, ShopliveSDKCommon.AFError>)
  public func request<Value>(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : ShopliveSDKCommon.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: ShopliveSDKCommon.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: ShopliveSDKCommon.Request, didFailToCreateURLRequestWithError error: ShopliveSDKCommon.AFError)
  final public func request(_ request: ShopliveSDKCommon.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: ShopliveSDKCommon.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: ShopliveSDKCommon.AFError)
  final public func request(_ request: ShopliveSDKCommon.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: ShopliveSDKCommon.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: ShopliveSDKCommon.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: ShopliveSDKCommon.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: ShopliveSDKCommon.AFError)
  final public func request(_ request: ShopliveSDKCommon.Request, didCompleteTask task: Foundation.URLSessionTask, with error: ShopliveSDKCommon.AFError?)
  final public func requestIsRetrying(_ request: ShopliveSDKCommon.Request)
  final public func requestDidFinish(_ request: ShopliveSDKCommon.Request)
  final public func requestDidResume(_ request: ShopliveSDKCommon.Request)
  final public func request(_ request: ShopliveSDKCommon.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: ShopliveSDKCommon.Request)
  final public func request(_ request: ShopliveSDKCommon.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: ShopliveSDKCommon.Request)
  final public func request(_ request: ShopliveSDKCommon.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: ShopliveSDKCommon.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  final public func request(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Foundation.Data?, ShopliveSDKCommon.AFError>)
  final public func request<Value>(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError>)
  final public func request(_ request: ShopliveSDKCommon.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  final public func request<Value>(_ request: ShopliveSDKCommon.DataStreamRequest, didParseStream result: Swift.Result<Value, ShopliveSDKCommon.AFError>)
  final public func request(_ request: ShopliveSDKCommon.UploadRequest, didCreateUploadable uploadable: ShopliveSDKCommon.UploadRequest.Uploadable)
  final public func request(_ request: ShopliveSDKCommon.UploadRequest, didFailToCreateUploadableWithError error: ShopliveSDKCommon.AFError)
  final public func request(_ request: ShopliveSDKCommon.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: ShopliveSDKCommon.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, ShopliveSDKCommon.AFError>)
  final public func request(_ request: ShopliveSDKCommon.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: ShopliveSDKCommon.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  final public func request(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Foundation.URL?, ShopliveSDKCommon.AFError>)
  final public func request<Value>(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : ShopliveSDKCommon.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((ShopliveSDKCommon.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((ShopliveSDKCommon.Request, ShopliveSDKCommon.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((ShopliveSDKCommon.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((ShopliveSDKCommon.Request, Foundation.URLRequest, ShopliveSDKCommon.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((ShopliveSDKCommon.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((ShopliveSDKCommon.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask, ShopliveSDKCommon.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask, ShopliveSDKCommon.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((ShopliveSDKCommon.Request) -> Swift.Void)?
  open var requestDidFinish: ((ShopliveSDKCommon.Request) -> Swift.Void)?
  open var requestDidResume: ((ShopliveSDKCommon.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((ShopliveSDKCommon.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((ShopliveSDKCommon.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((ShopliveSDKCommon.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((ShopliveSDKCommon.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, ShopliveSDKCommon.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((ShopliveSDKCommon.DataRequest, ShopliveSDKCommon.DataResponse<Foundation.Data?, ShopliveSDKCommon.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((ShopliveSDKCommon.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, ShopliveSDKCommon.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((ShopliveSDKCommon.UploadRequest, ShopliveSDKCommon.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((ShopliveSDKCommon.UploadRequest, ShopliveSDKCommon.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((ShopliveSDKCommon.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((ShopliveSDKCommon.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, ShopliveSDKCommon.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((ShopliveSDKCommon.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((ShopliveSDKCommon.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, ShopliveSDKCommon.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((ShopliveSDKCommon.DownloadRequest, ShopliveSDKCommon.DownloadResponse<Foundation.URL?, ShopliveSDKCommon.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: ShopliveSDKCommon.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: ShopliveSDKCommon.Request, didFailToCreateURLRequestWithError error: ShopliveSDKCommon.AFError)
  open func request(_ request: ShopliveSDKCommon.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: ShopliveSDKCommon.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: ShopliveSDKCommon.AFError)
  open func request(_ request: ShopliveSDKCommon.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: ShopliveSDKCommon.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: ShopliveSDKCommon.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: ShopliveSDKCommon.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: ShopliveSDKCommon.AFError)
  open func request(_ request: ShopliveSDKCommon.Request, didCompleteTask task: Foundation.URLSessionTask, with error: ShopliveSDKCommon.AFError?)
  open func requestIsRetrying(_ request: ShopliveSDKCommon.Request)
  open func requestDidFinish(_ request: ShopliveSDKCommon.Request)
  open func requestDidResume(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: ShopliveSDKCommon.Request)
  public func request(_ request: ShopliveSDKCommon.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: ShopliveSDKCommon.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  open func request(_ request: ShopliveSDKCommon.DataRequest, didParseResponse response: ShopliveSDKCommon.DataResponse<Foundation.Data?, ShopliveSDKCommon.AFError>)
  public func request(_ request: ShopliveSDKCommon.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  open func request(_ request: ShopliveSDKCommon.UploadRequest, didCreateUploadable uploadable: ShopliveSDKCommon.UploadRequest.Uploadable)
  open func request(_ request: ShopliveSDKCommon.UploadRequest, didFailToCreateUploadableWithError error: ShopliveSDKCommon.AFError)
  open func request(_ request: ShopliveSDKCommon.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: ShopliveSDKCommon.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, ShopliveSDKCommon.AFError>)
  open func request(_ request: ShopliveSDKCommon.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: ShopliveSDKCommon.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: ShopliveSDKCommon.Request.ValidationResult)
  open func request(_ request: ShopliveSDKCommon.DownloadRequest, didParseResponse response: ShopliveSDKCommon.DownloadResponse<Foundation.URL?, ShopliveSDKCommon.AFError>)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class LoadingIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static func show(isDimmed: Swift.Bool = true, key: Swift.String = "general", delay: Foundation.TimeInterval = 0)
  @_Concurrency.MainActor(unsafe) public static func hide(key: Swift.String = "general")
  @objc deinit
}
extension ShopliveSDKCommon.KeychainWrapper {
  public func remove(forKey key: ShopliveSDKCommon.KeychainWrapper.Key)
}
extension ShopliveSDKCommon.KeychainWrapper {
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.String? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Bool? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Int? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Double? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Float? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> CoreFoundation.CGFloat? {
    get
    set
  }
  public subscript(key: ShopliveSDKCommon.KeychainWrapper.Key) -> Foundation.Data? {
    get
    set
  }
}
extension ShopliveSDKCommon.KeychainWrapper {
  public func data(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Foundation.Data?
  public func bool(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Bool?
  public func integer(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Int?
  public func float(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Float?
  public func cgFloat(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> CoreFoundation.CGFloat?
  public func double(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.Double?
  public func string(forKey key: ShopliveSDKCommon.KeychainWrapper.Key) -> Swift.String?
}
extension ShopliveSDKCommon.KeychainWrapper {
  public struct Key : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
  }
}
@objc public protocol SLWebviewScrollDelegate {
  @objc optional func scrollViewDidScroll()
}
@objc public protocol SLWebviewResponseDelegate {
  @objc optional func handleShopliveEvent(_ command: Swift.String, with payload: [Swift.String : Any]?, userImplements: Swift.Bool)
  @objc optional func handleEventMessage(message: WebKit.WKScriptMessage)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class SLWebView : ShopliveSDKCommon.SLBaseView {
  @_Concurrency.MainActor(unsafe) weak final public var slWebResponseDelegate: ShopliveSDKCommon.SLWebviewResponseDelegate?
  @_Concurrency.MainActor(unsafe) weak final public var slWebScrollDelegate: ShopliveSDKCommon.SLWebviewScrollDelegate?
  @_Concurrency.MainActor(unsafe) override final public func layout()
  @_Concurrency.MainActor(unsafe) final public func load(_ request: Foundation.URLRequest)
  @_Concurrency.MainActor(unsafe) final public func reload()
  @_Concurrency.MainActor(unsafe) final public var url: Swift.String? {
    get
  }
  @_Concurrency.MainActor(unsafe) override final public func attributes()
  @_Concurrency.MainActor(unsafe) override final public func bindView()
  @objc deinit
  @_Concurrency.MainActor(unsafe) final public func close()
  @_Concurrency.MainActor(unsafe) final public func setScrollable(_ scrollable: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func configure(url: Swift.String)
  @_Concurrency.MainActor(unsafe) final public func configure(html: Swift.String)
  @_Concurrency.MainActor(unsafe) final public func sendEventToWeb(event: Swift.String, parameter: Any? = nil, wrapping: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) final public func sendShortsEvent(event: Swift.String, parameter: [Swift.String : Any]? = nil, completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension ShopliveSDKCommon.SLWebView : WebKit.WKScriptMessageHandler {
  @_Concurrency.MainActor(unsafe) @objc final public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
}
extension ShopliveSDKCommon.SLWebView : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
}
@objc public class LeakAvoider : ObjectiveC.NSObject, WebKit.WKScriptMessageHandler {
  public init(delegate: WebKit.WKScriptMessageHandler)
  @objc public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
  @objc deinit
}
extension Foundation.Data {
  public func convert<T>(to type: T.Type) -> T? where T : Swift.Decodable, T : Swift.Encodable
}
final public class NetworkMonitor : ShopliveSDKCommon.SLResultObservable {
  public enum ConnectionType {
    case wifi
    case cellular
    case disconnected
    case none
    public var isConnected: Swift.Bool {
      get
    }
    public var isInitialzed: Swift.Bool {
      get
    }
    public static func == (a: ShopliveSDKCommon.NetworkMonitor.ConnectionType, b: ShopliveSDKCommon.NetworkMonitor.ConnectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Result {
    case statusChanged(ShopliveSDKCommon.NetworkMonitor.ConnectionType)
  }
  final public var resultHandler: ((ShopliveSDKCommon.NetworkMonitor.Result) -> ())?
  public init()
  @objc deinit
  final public var isConnected: Swift.Bool {
    get
  }
}
public typealias PrefetcherProgressBlock = ((_ skippedResources: [ShopliveSDKCommon.Resource], _ failedResources: [ShopliveSDKCommon.Resource], _ completedResources: [ShopliveSDKCommon.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = ((_ skippedSources: [ShopliveSDKCommon.Source], _ failedSources: [ShopliveSDKCommon.Source], _ completedSources: [ShopliveSDKCommon.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = ((_ skippedResources: [ShopliveSDKCommon.Resource], _ failedResources: [ShopliveSDKCommon.Resource], _ completedResources: [ShopliveSDKCommon.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = ((_ skippedSources: [ShopliveSDKCommon.Source], _ failedSources: [ShopliveSDKCommon.Source], _ completedSources: [ShopliveSDKCommon.Source]) -> Swift.Void)
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.PrefetcherProgressBlock? = nil, completionHandler: ShopliveSDKCommon.PrefetcherCompletionHandler? = nil)
  convenience public init(urls: [Foundation.URL], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ShopliveSDKCommon.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [ShopliveSDKCommon.Resource], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.PrefetcherProgressBlock? = nil, completionHandler: ShopliveSDKCommon.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [ShopliveSDKCommon.Resource], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ShopliveSDKCommon.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [ShopliveSDKCommon.Source], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.PrefetcherSourceProgressBlock? = nil, completionHandler: ShopliveSDKCommon.PrefetcherSourceCompletionHandler? = nil)
  convenience public init(sources: [ShopliveSDKCommon.Source], options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ShopliveSDKCommon.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
public struct ImageCreatingOptions {
  public let scale: CoreFoundation.CGFloat
  public let duration: Foundation.TimeInterval
  public let preloadAll: Swift.Bool
  public let onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
extension Photos.PHAsset {
  public func getURL(completionHandler: @escaping ((_ responseURL: Foundation.URL?) -> Swift.Void))
}
public struct BaseError : Swift.Codable {
  public let status: Swift.Int
  public let error: Swift.String, message: Swift.String
  public let timestamp: Swift.Int?
  public let path: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers public class ShopLiveError : Foundation.NSError {
  public var message: Swift.String
  public var isSilence: Swift.Bool
  @objc override dynamic public init(domain: Swift.String, code: Swift.Int, userInfo dict: [Swift.String : Any]? = nil)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DeflateRequestCompressor : ShopliveSDKCommon.RequestInterceptor {
  public enum DuplicateHeaderBehavior {
    case error
    case replace
    case skip
    public static func == (a: ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior, b: ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct DuplicateHeaderError : Swift.Error {
  }
  public let duplicateHeaderBehavior: ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior
  public let shouldCompressBodyData: (_ bodyData: Foundation.Data) -> Swift.Bool
  public init(duplicateHeaderBehavior: ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true })
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.RequestInterceptor where Self == ShopliveSDKCommon.DeflateRequestCompressor {
  public static var deflateCompressor: ShopliveSDKCommon.DeflateRequestCompressor {
    get
  }
  public static func deflateCompressor(duplicateHeaderBehavior: ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true }) -> ShopliveSDKCommon.DeflateRequestCompressor
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: ShopliveSDKCommon.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : ShopliveSDKCommon.ResponseSerializer
  public init<Serializer>(_ request: ShopliveSDKCommon.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : ShopliveSDKCommon.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, ShopliveSDKCommon.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, ShopliveSDKCommon.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension ShopliveSDKCommon.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: ShopliveSDKCommon.DataRequest, queue: Dispatch.DispatchQueue)
}
extension ShopliveSDKCommon.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DataResponsePublisher<T> where Serializer : ShopliveSDKCommon.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = ShopliveSDKCommon.DataStreamRequest.Stream<Value, ShopliveSDKCommon.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: ShopliveSDKCommon.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : ShopliveSDKCommon.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, ShopliveSDKCommon.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, ShopliveSDKCommon.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ShopliveSDKCommon.DataStreamRequest.Stream<Value, ShopliveSDKCommon.AFError>
}
extension ShopliveSDKCommon.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DataStreamPublisher<Serializer.SerializedObject> where Serializer : ShopliveSDKCommon.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), preprocessor: ShopliveSDKCommon.DataPreprocessor = PassthroughPreprocessor()) -> ShopliveSDKCommon.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: ShopliveSDKCommon.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : ShopliveSDKCommon.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: ShopliveSDKCommon.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : ShopliveSDKCommon.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, ShopliveSDKCommon.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, ShopliveSDKCommon.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError>
}
extension ShopliveSDKCommon.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DownloadResponsePublisher<T> where Serializer : ShopliveSDKCommon.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DownloadResponsePublisher<T> where Serializer : ShopliveSDKCommon.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension ShopliveSDKCommon.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: ShopliveSDKCommon.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension ShopliveSDKCommon.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> ShopliveSDKCommon.DownloadResponsePublisher<Foundation.URL?>
}
public struct FormatIndicatedCacheSerializer : ShopliveSDKCommon.CacheSerializer {
  public static let png: ShopliveSDKCommon.FormatIndicatedCacheSerializer
  public static let jpeg: ShopliveSDKCommon.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> ShopliveSDKCommon.FormatIndicatedCacheSerializer
  public static let gif: ShopliveSDKCommon.FormatIndicatedCacheSerializer
  public func data(with image: ShopliveSDKCommon.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public enum PanDirection : Swift.Int {
  case up, down, left, right
  public var isVertical: Swift.Bool {
    get
  }
  public var isHorizontal: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension UIKit.UIPanGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public var direction: ShopliveSDKCommon.PanDirection? {
    get
  }
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, attributedView: @autoclosure @escaping () -> ShopliveSDKCommon.KFCrossPlatformView, placeholder: ShopliveSDKCommon.KFCrossPlatformImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with resource: ShopliveSDKCommon.Resource?, attributedView: @autoclosure @escaping () -> ShopliveSDKCommon.KFCrossPlatformView, placeholder: ShopliveSDKCommon.KFCrossPlatformImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  public func cancelDownloadTask()
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.NSTextAttachment {
  public var taskIdentifier: ShopliveSDKCommon.Source.Identifier.Value? {
    get
  }
}
@_hasMissingDesignatedInitializers public class RetryContext {
  final public let source: ShopliveSDKCommon.Source
  final public let error: ShopliveSDKCommon.SLKingfisherError
  public var retriedCount: Swift.Int
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy {
  func retry(context: ShopliveSDKCommon.RetryContext, retryHandler: @escaping (ShopliveSDKCommon.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : ShopliveSDKCommon.RetryStrategy {
  public enum Interval {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: ShopliveSDKCommon.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: ShopliveSDKCommon.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: ShopliveSDKCommon.RetryContext, retryHandler: @escaping (ShopliveSDKCommon.RetryDecision) -> Swift.Void)
}
extension Swift.String {
  public func versionCompare(_ otherVersion: Swift.String) -> Foundation.ComparisonResult
  public var trimmed: Swift.String {
    get
  }
  public var isEmptyText: Swift.Bool {
    get
  }
  public var isSingleWordEmptyText: Swift.Bool {
    get
  }
  public var trimWhiteSpacing: Swift.String {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public func removeJWTPadding() -> Swift.String
  public var urlEncodedString: Swift.String? {
    get
  }
  public var urlEncodedStringRFC3986: Swift.String? {
    get
  }
  public var dictionary: [Swift.AnyHashable : Any]? {
    get
  }
  public func localizedString(from: Swift.String = "Localizable", bundle: Foundation.Bundle = Bundle.main, comment: Swift.String = "") -> Swift.String
  public func fotmattedString() -> Swift.String
  public func CGFloatValue() -> CoreFoundation.CGFloat?
  public var cgfloatValue: CoreFoundation.CGFloat? {
    get
  }
  public var toJsonValue: Swift.String {
    get
  }
  public var base64Decoded: Swift.String? {
    get
  }
  public var base64Encoded: Swift.String? {
    get
  }
  public func convert<T>(to type: T.Type) -> T? where T : Swift.Decodable, T : Swift.Encodable
}
@_hasMissingDesignatedInitializers public class SessionDataTask {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for task: ShopliveSDKCommon.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : ShopliveSDKCommon.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: ShopliveSDKCommon.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (ShopliveSDKCommon.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
@_hasMissingDesignatedInitializers final public class AudioSessionManager {
  public static var shared: ShopliveSDKCommon.AudioSessionManager
  final public var customerAudioCategoryOptions: AVFAudio.AVAudioSession.CategoryOptions
  final public var currentCategoryOptions: AVFAudio.AVAudioSession.CategoryOptions {
    get
  }
  final public func setCategory(category: AVFAudio.AVAudioSession.Category, options: AVFAudio.AVAudioSession.CategoryOptions)
  @objc deinit
}
extension Swift.Encodable {
  public func toDictionary(_ encoder: Foundation.JSONEncoder = JSONEncoder()) throws -> [Swift.String : Any]
  public var dictionary: [Swift.String : Any]? {
    get
  }
}
extension ObjectiveC.NSObject {
  public func safeRemoveObserver(_ observer: Any, forKeyPath keyPath: Swift.String)
}
public protocol AnyNameable {
  static func className() -> Swift.String
}
extension ShopliveSDKCommon.AnyNameable {
  public static func className() -> Swift.String
}
extension ObjectiveC.NSObject : ShopliveSDKCommon.AnyNameable {
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct SLKingfisherWrapper<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol SLKingfisherCompatible : AnyObject {
}
public protocol SLKingfisherCompatibleValue {
}
extension ShopliveSDKCommon.SLKingfisherCompatible {
  public var kf: ShopliveSDKCommon.SLKingfisherWrapper<Self> {
    get
    set
  }
}
extension ShopliveSDKCommon.SLKingfisherCompatibleValue {
  public var kf: ShopliveSDKCommon.SLKingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : ShopliveSDKCommon.SLKingfisherCompatible {
}
extension UIKit.UIImageView : ShopliveSDKCommon.SLKingfisherCompatible {
}
extension UIKit.UIButton : ShopliveSDKCommon.SLKingfisherCompatible {
}
extension UIKit.NSTextAttachment : ShopliveSDKCommon.SLKingfisherCompatible {
}
@available(iOS 14.0, *)
extension CarPlay.CPListItem : ShopliveSDKCommon.SLKingfisherCompatible {
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct KFImage : ShopliveSDKCommon.KFImageProtocol {
  public var context: ShopliveSDKCommon.KFImage.Context<SwiftUI.Image>
  public init(context: ShopliveSDKCommon.KFImage.Context<SwiftUI.Image>)
  public typealias Body = @_opaqueReturnTypeOf("$s17ShopliveSDKCommon15KFImageProtocolPAAE4bodyQrvp", 0) __<ShopliveSDKCommon.KFImage>
  public typealias HoldingView = SwiftUI.Image
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUI.Image : ShopliveSDKCommon.KFImageHoldingView {
  public typealias RenderingView = SwiftUI.Image
  public static func created(from image: ShopliveSDKCommon.KFCrossPlatformImage?, context: ShopliveSDKCommon.KFImage.Context<SwiftUI.Image>) -> SwiftUI.Image
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImage {
  public func resizable(capInsets: SwiftUI.EdgeInsets = EdgeInsets(), resizingMode: SwiftUI.Image.ResizingMode = .stretch) -> ShopliveSDKCommon.KFImage
  public func renderingMode(_ renderingMode: SwiftUI.Image.TemplateRenderingMode?) -> ShopliveSDKCommon.KFImage
  public func interpolation(_ interpolation: SwiftUI.Image.Interpolation) -> ShopliveSDKCommon.KFImage
  public func antialiased(_ isAntialiased: Swift.Bool) -> ShopliveSDKCommon.KFImage
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> ShopliveSDKCommon.KFImage
}
public class JSONNull : Swift.Codable, Swift.Hashable {
  public static func == (lhs: ShopliveSDKCommon.JSONNull, rhs: ShopliveSDKCommon.JSONNull) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
open class Session {
  public static let `default`: ShopliveSDKCommon.Session
  final public let session: Foundation.URLSession
  final public let delegate: ShopliveSDKCommon.AFSessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: ShopliveSDKCommon.RequestInterceptor?
  final public let serverTrustManager: ShopliveSDKCommon.ServerTrustManager?
  final public let redirectHandler: ShopliveSDKCommon.RedirectHandler?
  final public let cachedResponseHandler: ShopliveSDKCommon.CachedResponseHandler?
  final public let eventMonitor: ShopliveSDKCommon.CompositeEventMonitor
  final public let defaultEventMonitors: [ShopliveSDKCommon.EventMonitor]
  public init(session: Foundation.URLSession, delegate: ShopliveSDKCommon.AFSessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, serverTrustManager: ShopliveSDKCommon.ServerTrustManager? = nil, redirectHandler: ShopliveSDKCommon.RedirectHandler? = nil, cachedResponseHandler: ShopliveSDKCommon.CachedResponseHandler? = nil, eventMonitors: [ShopliveSDKCommon.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: ShopliveSDKCommon.AFSessionDelegate = AFSessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, serverTrustManager: ShopliveSDKCommon.ServerTrustManager? = nil, redirectHandler: ShopliveSDKCommon.RedirectHandler? = nil, cachedResponseHandler: ShopliveSDKCommon.CachedResponseHandler? = nil, eventMonitors: [ShopliveSDKCommon.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<ShopliveSDKCommon.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, parameters: ShopliveSDKCommon.Parameters? = nil, encoding: ShopliveSDKCommon.ParameterEncoding = URLEncoding.default, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.DataRequest
  open func request<Parameters>(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, parameters: Parameters? = nil, encoder: ShopliveSDKCommon.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: ShopliveSDKCommon.URLRequestConvertible, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil) -> ShopliveSDKCommon.DataRequest
  open func streamRequest<Parameters>(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, parameters: Parameters? = nil, encoder: ShopliveSDKCommon.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: ShopliveSDKCommon.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, headers: ShopliveSDKCommon.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.DataStreamRequest
  open func streamRequest(_ convertible: ShopliveSDKCommon.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil) -> ShopliveSDKCommon.DataStreamRequest
  open func download(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, parameters: ShopliveSDKCommon.Parameters? = nil, encoding: ShopliveSDKCommon.ParameterEncoding = URLEncoding.default, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil, to destination: ShopliveSDKCommon.DownloadRequest.Destination? = nil) -> ShopliveSDKCommon.DownloadRequest
  open func download<Parameters>(_ convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .get, parameters: Parameters? = nil, encoder: ShopliveSDKCommon.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil, to destination: ShopliveSDKCommon.DownloadRequest.Destination? = nil) -> ShopliveSDKCommon.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: ShopliveSDKCommon.URLRequestConvertible, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, to destination: ShopliveSDKCommon.DownloadRequest.Destination? = nil) -> ShopliveSDKCommon.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, to destination: ShopliveSDKCommon.DownloadRequest.Destination? = nil) -> ShopliveSDKCommon.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .post, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: ShopliveSDKCommon.URLRequestConvertible, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> ShopliveSDKCommon.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .post, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: ShopliveSDKCommon.URLRequestConvertible, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> ShopliveSDKCommon.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod = .post, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: ShopliveSDKCommon.URLRequestConvertible, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> ShopliveSDKCommon.UploadRequest
  open func upload(multipartFormData: @escaping (ShopliveSDKCommon.MultipartFormData) -> Swift.Void, to url: ShopliveSDKCommon.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: ShopliveSDKCommon.HTTPMethod = .post, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.UploadRequest
  open func upload(multipartFormData: @escaping (ShopliveSDKCommon.MultipartFormData) -> Swift.Void, with request: ShopliveSDKCommon.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> ShopliveSDKCommon.UploadRequest
  open func upload(multipartFormData: ShopliveSDKCommon.MultipartFormData, to url: ShopliveSDKCommon.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: ShopliveSDKCommon.HTTPMethod = .post, headers: ShopliveSDKCommon.HTTPHeaders? = nil, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: ShopliveSDKCommon.Session.RequestModifier? = nil) -> ShopliveSDKCommon.UploadRequest
  open func upload(multipartFormData: ShopliveSDKCommon.MultipartFormData, with request: ShopliveSDKCommon.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: ShopliveSDKCommon.RequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> ShopliveSDKCommon.UploadRequest
}
extension ShopliveSDKCommon.Session : ShopliveSDKCommon.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: ShopliveSDKCommon.Request)
  public func retryResult(for request: ShopliveSDKCommon.Request, dueTo error: ShopliveSDKCommon.AFError, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: ShopliveSDKCommon.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol KFImageProtocol : ShopliveSDKCommon.KFOptionSetter, SwiftUI.View {
  associatedtype HoldingView : ShopliveSDKCommon.KFImageHoldingView
  var context: ShopliveSDKCommon.KFImage.Context<Self.HoldingView> { get set }
  init(context: ShopliveSDKCommon.KFImage.Context<Self.HoldingView>)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImageProtocol {
  public var body: some SwiftUI.View {
    get
  }
  public init(source: ShopliveSDKCommon.Source?)
  public init(_ url: Foundation.URL?)
  public func configure(_ block: @escaping (Self.HoldingView) -> Self.HoldingView) -> Self
  public func contentConfigure<V>(_ block: @escaping (Self.HoldingView) -> V) -> Self where V : SwiftUI.View
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public protocol KFImageHoldingView : SwiftUI.View {
  associatedtype RenderingView
  static func created(from image: ShopliveSDKCommon.KFCrossPlatformImage?, context: ShopliveSDKCommon.KFImage.Context<Self>) -> Self
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImageProtocol {
  public var options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo {
    get
    nonmutating set
  }
  public var onFailureDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.SLKingfisherError, Swift.Void> {
    get
  }
  public var onSuccessDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.RetrieveImageResult, Swift.Void> {
    get
  }
  public var onProgressDelegate: ShopliveSDKCommon.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> {
    get
  }
  public var delegateObserver: Swift.AnyObject {
    get
  }
}
extension Swift.Collection {
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
  public var isNotEmpty: Swift.Bool {
    get
  }
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: ShopliveSDKCommon.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public protocol SLResultObservable {
  associatedtype Result
  var resultHandler: ((Self.Result) -> ())? { get set }
}
public struct KeychainData : Swift.Equatable {
  public static func == (lhs: ShopliveSDKCommon.KeychainData, rhs: ShopliveSDKCommon.KeychainData) -> Swift.Bool
}
public protocol KFOptionSetter {
  var options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo { get nonmutating set }
  var onFailureDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.SLKingfisherError, Swift.Void> { get }
  var onSuccessDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.RetrieveImageResult, Swift.Void> { get }
  var onProgressDelegate: ShopliveSDKCommon.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
  var delegateObserver: Swift.AnyObject { get }
}
extension ShopliveSDKCommon.KF.Builder : ShopliveSDKCommon.KFOptionSetter {
  public var delegateObserver: Swift.AnyObject {
    get
  }
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func onProgress(_ block: ShopliveSDKCommon.DownloadProgressBlock?) -> Self
  public func onSuccess(_ block: ((ShopliveSDKCommon.RetrieveImageResult) -> Swift.Void)?) -> Self
  public func onFailure(_ block: ((ShopliveSDKCommon.SLKingfisherError) -> Swift.Void)?) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func targetCache(_ cache: ShopliveSDKCommon.ImageCache) -> Self
  public func originalCache(_ cache: ShopliveSDKCommon.ImageCache) -> Self
  public func downloader(_ downloader: ShopliveSDKCommon.ImageDownloader) -> Self
  public func downloadPriority(_ priority: Swift.Float) -> Self
  public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  public func callbackQueue(_ queue: ShopliveSDKCommon.CallbackQueue) -> Self
  public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  public func processingQueue(_ queue: ShopliveSDKCommon.CallbackQueue?) -> Self
  public func alternativeSources(_ sources: [ShopliveSDKCommon.Source]?) -> Self
  public func retry(_ strategy: ShopliveSDKCommon.RetryStrategy?) -> Self
  public func retry(maxCount: Swift.Int, interval: ShopliveSDKCommon.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  public func lowDataModeSource(_ source: ShopliveSDKCommon.Source?) -> Self
  public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  public func onFailureImage(_ image: ShopliveSDKCommon.KFCrossPlatformImage?) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func requestModifier(_ modifier: ShopliveSDKCommon.AsyncImageDownloadRequestModifier) -> Self
  public func requestModifier(_ modifyBlock: @escaping (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func redirectHandler(_ handler: ShopliveSDKCommon.ImageDownloadRedirectHandler) -> Self
  public func redirectHandler(_ block: @escaping (ShopliveSDKCommon.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func setProcessor(_ processor: ShopliveSDKCommon.ImageProcessor) -> Self
  public func setProcessors(_ processors: [ShopliveSDKCommon.ImageProcessor]) -> Self
  public func appendProcessor(_ processor: ShopliveSDKCommon.ImageProcessor) -> Self
  public func roundCorner(radius: ShopliveSDKCommon.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ShopliveSDKCommon.RectCorner = .all, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil) -> Self
  public func blur(radius: CoreFoundation.CGFloat) -> Self
  public func overlay(color: ShopliveSDKCommon.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  public func tint(color: ShopliveSDKCommon.KFCrossPlatformColor) -> Self
  public func blackWhite() -> Self
  public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  public func downsampling(size: CoreFoundation.CGSize) -> Self
  public func resizing(referenceSize: CoreFoundation.CGSize, mode: ShopliveSDKCommon.ContentMode = .none) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func serialize(by cacheSerializer: ShopliveSDKCommon.CacheSerializer) -> Self
  public func serialize(as format: ShopliveSDKCommon.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func imageModifier(_ modifier: ShopliveSDKCommon.ImageModifier?) -> Self
  public func imageModifier(_ block: @escaping (inout ShopliveSDKCommon.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension ShopliveSDKCommon.KFOptionSetter {
  public func memoryCacheExpiration(_ expiration: ShopliveSDKCommon.StorageExpiration?) -> Self
  public func memoryCacheAccessExtending(_ extending: ShopliveSDKCommon.ExpirationExtending) -> Self
  public func diskCacheExpiration(_ expiration: ShopliveSDKCommon.StorageExpiration?) -> Self
  public func diskCacheAccessExtending(_ extending: ShopliveSDKCommon.ExpirationExtending) -> Self
}
extension WebKit.WKWebView {
  @_Concurrency.MainActor(unsafe) public static let progressKeypath: Swift.String
  @_Concurrency.MainActor(unsafe) public static var urlErrors: [Swift.Int] {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static let SLKingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let SLKingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: ShopliveSDKCommon.CacheType, b: ShopliveSDKCommon.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), ShopliveSDKCommon.SLKingfisherError>
}
extension UIKit.UIImage : ShopliveSDKCommon.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : ShopliveSDKCommon.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult {
  case disk(ShopliveSDKCommon.KFCrossPlatformImage)
  case memory(ShopliveSDKCommon.KFCrossPlatformImage)
  case none
  public var image: ShopliveSDKCommon.KFCrossPlatformImage? {
    get
  }
  public var cacheType: ShopliveSDKCommon.CacheType {
    get
  }
}
open class ImageCache {
  public static let `default`: ShopliveSDKCommon.ImageCache
  final public let memoryStorage: ShopliveSDKCommon.MemoryStorage.Backend<ShopliveSDKCommon.KFCrossPlatformImage>
  final public let diskStorage: ShopliveSDKCommon.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: ShopliveSDKCommon.MemoryStorage.Backend<ShopliveSDKCommon.KFCrossPlatformImage>, diskStorage: ShopliveSDKCommon.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: ShopliveSDKCommon.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: ShopliveSDKCommon.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: ((ShopliveSDKCommon.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: ShopliveSDKCommon.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: ShopliveSDKCommon.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: ShopliveSDKCommon.CallbackQueue = .untouch, completionHandler: ((ShopliveSDKCommon.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: ShopliveSDKCommon.StorageExpiration? = nil, callbackQueue: ShopliveSDKCommon.CallbackQueue = .untouch, completionHandler: ((ShopliveSDKCommon.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: ShopliveSDKCommon.CallbackQueue = .untouch, completionHandler: (() -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo, callbackQueue: ShopliveSDKCommon.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<ShopliveSDKCommon.ImageCacheResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)?)
  open func retrieveImage(forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, callbackQueue: ShopliveSDKCommon.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<ShopliveSDKCommon.ImageCacheResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil) -> ShopliveSDKCommon.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, callbackQueue: ShopliveSDKCommon.CallbackQueue = .untouch, completionHandler: @escaping (Swift.Result<ShopliveSDKCommon.KFCrossPlatformImage?, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> ShopliveSDKCommon.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping ((Swift.Result<Swift.UInt, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void))
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
  #endif
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
}
extension UIKit.UIApplication : ShopliveSDKCommon.SLKingfisherCompatible {
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
extension CoreMedia.CMTime {
  public var timeSeconds: Swift.Float64? {
    get
  }
  public var isValid: Swift.Bool {
    get
  }
  public var roundedSeconds: Foundation.TimeInterval {
    get
  }
}
extension UIKit.UIFont {
  public func findAvailableFont() -> UIKit.UIFont
  public func lineHeightMultiple(_ lineHeight: CoreFoundation.CGFloat = 20) -> CoreFoundation.CGFloat
}
extension ShopliveSDKCommon.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: ShopliveSDKCommon.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : ShopliveSDKCommon.EventMonitor {
  final public func requestDidResume(_ request: ShopliveSDKCommon.Request)
  final public func requestDidSuspend(_ request: ShopliveSDKCommon.Request)
  final public func requestDidCancel(_ request: ShopliveSDKCommon.Request)
  final public func requestDidFinish(_ request: ShopliveSDKCommon.Request)
  final public func request(_ request: ShopliveSDKCommon.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: ShopliveSDKCommon.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: ShopliveSDKCommon.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: ShopliveSDKCommon.Request, didCompleteTask task: Foundation.URLSessionTask, with error: ShopliveSDKCommon.AFError?)
  @objc deinit
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding, b: ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public struct KeyPathEncoding {
    public static let brackets: ShopliveSDKCommon.URLEncodedFormEncoder.KeyPathEncoding
    public static let dots: ShopliveSDKCommon.URLEncodedFormEncoder.KeyPathEncoding
    public init(encoding: @escaping (_ subkey: Swift.String) -> Swift.String)
  }
  public struct NilEncoding {
    public static let dropKey: ShopliveSDKCommon.URLEncodedFormEncoder.NilEncoding
    public static let dropValue: ShopliveSDKCommon.URLEncodedFormEncoder.NilEncoding
    public static let null: ShopliveSDKCommon.URLEncodedFormEncoder.NilEncoding
    public init(encoding: @escaping () -> Swift.String?)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding, b: ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.KeyEncoding
  final public let keyPathEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.KeyPathEncoding
  final public let nilEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.NilEncoding
  final public let spaceEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, keyPathEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.KeyPathEncoding = .brackets, nilEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.NilEncoding = .dropKey, spaceEncoding: ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: ShopliveSDKCommon.ResponseCacher
  public static let doNotCache: ShopliveSDKCommon.ResponseCacher
  public let behavior: ShopliveSDKCommon.ResponseCacher.Behavior
  public init(behavior: ShopliveSDKCommon.ResponseCacher.Behavior)
}
extension ShopliveSDKCommon.ResponseCacher : ShopliveSDKCommon.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension ShopliveSDKCommon.CachedResponseHandler where Self == ShopliveSDKCommon.ResponseCacher {
  public static var cache: ShopliveSDKCommon.ResponseCacher {
    get
  }
  public static var doNotCache: ShopliveSDKCommon.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> ShopliveSDKCommon.ResponseCacher
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: ShopliveSDKCommon.KFCrossPlatformImage {
    get
  }
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: ShopliveSDKCommon.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: ShopliveSDKCommon.ImageCreatingOptions) -> ShopliveSDKCommon.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: ShopliveSDKCommon.ImageCreatingOptions) -> ShopliveSDKCommon.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public protocol BaseResponsable : Swift.Decodable, Swift.Encodable {
  var _s: Swift.Int? { get set }
  var _e: Swift.String? { get set }
}
extension ShopliveSDKCommon.BaseResponsable {
  public var isBaseModel: Swift.Bool {
    get
  }
  public var isSuccess: Swift.Bool {
    get
  }
}
public struct BaseResponse : ShopliveSDKCommon.BaseResponsable {
  public var _s: Swift.Int?
  public var _e: Swift.String?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum HTTPVersion : Swift.String {
  case v1, v2
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SLHTTPMethod {
  case get
  case post
  case put
  case delete
  public static func == (a: ShopliveSDKCommon.SLHTTPMethod, b: ShopliveSDKCommon.SLHTTPMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol APIDefinition {
  associatedtype ResultType : ShopliveSDKCommon.BaseResponsable
  var baseUrl: Swift.String { get }
  var urlPath: Swift.String { get }
  var method: ShopliveSDKCommon.SLHTTPMethod { get }
  var parameters: [Swift.String : Any]? { get }
  var uploadParameters: [Swift.String : Any] { get }
  var timeoutInterval: Swift.Double { get }
  var headers: [Swift.String : Swift.String] { get }
  var version: ShopliveSDKCommon.HTTPVersion { get }
  var needToShowLoadingIndicator: Swift.Bool { get }
}
extension ShopliveSDKCommon.APIDefinition {
  public var method: ShopliveSDKCommon.HTTPMethod {
    get
  }
  public var baseUrl: Swift.String {
    get
  }
  public var parameters: [Swift.String : Any]? {
    get
  }
  public var timeoutInterval: Swift.Double {
    get
  }
  public var headers: [Swift.String : Swift.String] {
    get
  }
  public var version: ShopliveSDKCommon.HTTPVersion {
    get
  }
  public var needToShowLoadingIndicator: Swift.Bool {
    get
  }
  public var uploadParameters: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers final public class APIDefinitionCancellable {
  final public func cancel()
  @objc deinit
}
extension ShopliveSDKCommon.APIDefinition {
  @discardableResult
  public func request(handler: ((Swift.Result<Self.ResultType, Swift.Error>) -> ())? = nil) -> ShopliveSDKCommon.APIDefinitionCancellable
  @discardableResult
  public func upload(handler: ((Swift.Result<Self.ResultType, Swift.Error>) -> ())? = nil) -> ShopliveSDKCommon.APIDefinitionCancellable
}
extension UIKit.UIApplication {
  @_Concurrency.MainActor(unsafe) public static var isLandscape: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public static func openSettings()
  @_Concurrency.MainActor(unsafe) public static func openBrowser(url: Swift.String)
  @_Concurrency.MainActor(unsafe) public static func openAppstore(appId: Swift.String)
  @_Concurrency.MainActor(unsafe) public class func appVersion() -> Swift.String
  @_Concurrency.MainActor(unsafe) public class func appBuild() -> Swift.String
  @_Concurrency.MainActor(unsafe) public class func versionBuild() -> Swift.String
  @_Concurrency.MainActor(unsafe) public static var topWindow: UIKit.UIWindow? {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var firstWindow: UIKit.UIWindow? {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var windowList: [UIKit.UIWindow]? {
    get
  }
}
public protocol Placeholder {
  func add(to imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
  func remove(from imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
}
extension UIKit.UIImage : ShopliveSDKCommon.Placeholder {
  public func add(to imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
  public func remove(from imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
}
extension ShopliveSDKCommon.Placeholder where Self : UIKit.UIView {
  public func add(to imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
  public func remove(from imageView: ShopliveSDKCommon.KFCrossPlatformImageView)
}
public enum KeychainItemAccessibility {
  @available(iOS 4, *)
  case afterFirstUnlock
  @available(iOS 4, *)
  case afterFirstUnlockThisDeviceOnly
  @available(iOS 4, *)
  case always
  @available(iOS 8, *)
  case whenPasscodeSetThisDeviceOnly
  @available(iOS 4, *)
  case alwaysThisDeviceOnly
  @available(iOS 4, *)
  case whenUnlocked
  @available(iOS 4, *)
  case whenUnlockedThisDeviceOnly
  public static func == (a: ShopliveSDKCommon.KeychainItemAccessibility, b: ShopliveSDKCommon.KeychainItemAccessibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum StorageExpiration {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending {
  case none
  case cacheTime
  case expirationTime(_: ShopliveSDKCommon.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
extension UIKit.UIScreen {
  @_Concurrency.MainActor(unsafe) public static var safeArea: UIKit.UIEdgeInsets {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var currentOrientation: UIKit.UIInterfaceOrientation {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var isLandscape: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var concreteWidth: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var concreteHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var landscapeWidth: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var landscapeHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var screenWidth: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var screenHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var concreteTopSafeArea: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var topSafeArea: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var leftSafeArea: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var rightSafeArea: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public static var bottomSafeArea: CoreFoundation.CGFloat {
    get
  }
}
extension UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) public func numberOfLines(lineHeight: CoreFoundation.CGFloat = 20) -> Swift.Int
}
public protocol ImageModifier {
  func modify(_ image: ShopliveSDKCommon.KFCrossPlatformImage) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public struct AnyImageModifier : ShopliveSDKCommon.ImageModifier {
  public init(modify: @escaping (ShopliveSDKCommon.KFCrossPlatformImage) throws -> ShopliveSDKCommon.KFCrossPlatformImage)
  public func modify(_ image: ShopliveSDKCommon.KFCrossPlatformImage) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : ShopliveSDKCommon.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: ShopliveSDKCommon.KFCrossPlatformImage) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : ShopliveSDKCommon.ImageModifier {
  public init()
  public func modify(_ image: ShopliveSDKCommon.KFCrossPlatformImage) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : ShopliveSDKCommon.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: ShopliveSDKCommon.KFCrossPlatformImage) -> ShopliveSDKCommon.KFCrossPlatformImage
}
public typealias AFDataResponse<Success> = ShopliveSDKCommon.DataResponse<Success, ShopliveSDKCommon.AFError>
public typealias AFDownloadResponse<Success> = ShopliveSDKCommon.DownloadResponse<Success, ShopliveSDKCommon.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension ShopliveSDKCommon.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ShopliveSDKCommon.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> ShopliveSDKCommon.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> ShopliveSDKCommon.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> ShopliveSDKCommon.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> ShopliveSDKCommon.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension ShopliveSDKCommon.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ShopliveSDKCommon.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> ShopliveSDKCommon.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> ShopliveSDKCommon.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> ShopliveSDKCommon.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> ShopliveSDKCommon.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public typealias AFResult<Success> = Swift.Result<Success, ShopliveSDKCommon.AFError>
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with resource: ShopliveSDKCommon.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  public func cancelImageDownloadTask()
  @discardableResult
  public func setBackgroundImage(with source: ShopliveSDKCommon.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setBackgroundImage(with resource: ShopliveSDKCommon.Resource?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  public func cancelBackgroundImageDownloadTask()
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIButton {
  public func taskIdentifier(for state: UIKit.UIControl.State) -> ShopliveSDKCommon.Source.Identifier.Value?
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIButton {
  public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> ShopliveSDKCommon.Source.Identifier.Value?
}
public protocol ActionReceivable {
  associatedtype Action
  func action(_ action: Self.Action)
}
public protocol SLReactor : ShopliveSDKCommon.ActionReceivable, ShopliveSDKCommon.SLResultObservable {
}
public let AF: ShopliveSDKCommon.Session
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: ShopliveSDKCommon.HTTPMethod
  public static let delete: ShopliveSDKCommon.HTTPMethod
  public static let get: ShopliveSDKCommon.HTTPMethod
  public static let head: ShopliveSDKCommon.HTTPMethod
  public static let options: ShopliveSDKCommon.HTTPMethod
  public static let patch: ShopliveSDKCommon.HTTPMethod
  public static let post: ShopliveSDKCommon.HTTPMethod
  public static let put: ShopliveSDKCommon.HTTPMethod
  public static let query: ShopliveSDKCommon.HTTPMethod
  public static let trace: ShopliveSDKCommon.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : ShopliveSDKCommon.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : ShopliveSDKCommon.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : ShopliveSDKCommon.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension ShopliveSDKCommon.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : ShopliveSDKCommon.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: ShopliveSDKCommon.URLConvertible, method: ShopliveSDKCommon.HTTPMethod, headers: ShopliveSDKCommon.HTTPHeaders? = nil) throws
}
public struct ImageLoadingResult {
  public let image: ShopliveSDKCommon.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
}
public struct SLDownloadTask {
  public let sessionTask: ShopliveSDKCommon.SessionDataTask
  public let cancelToken: ShopliveSDKCommon.SessionDataTask.CancelToken
  public func cancel()
}
open class ImageDownloader {
  public static let `default`: ShopliveSDKCommon.ImageDownloader
  open var downloadTimeout: Swift.Double
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: ShopliveSDKCommon.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: ShopliveSDKCommon.ImageDownloaderDelegate?
  weak open var authenticationChallengeResponder: ShopliveSDKCommon.AuthenticationChallengeResponsible?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo, completionHandler: ((Swift.Result<ShopliveSDKCommon.ImageLoadingResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.ImageLoadingResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.ImageLoadingResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
}
extension ShopliveSDKCommon.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension ShopliveSDKCommon.ImageDownloader : ShopliveSDKCommon.AuthenticationChallengeResponsible {
}
extension ShopliveSDKCommon.ImageDownloader : ShopliveSDKCommon.ImageDownloaderDelegate {
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: ShopliveSDKCommon.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping ShopliveSDKCommon.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus, b: ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
extension Swift.Array {
  public subscript(safe index: Swift.Int) -> Element? {
    get
  }
  public subscript(safe range: Swift.Range<Swift.Array<Element>.Index>) -> Swift.ArraySlice<Element> {
    get
  }
  public func chunked(into size: Swift.Int) -> [[Element]]
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
}
extension Swift.Array where Element == Swift.String {
  public func reducedWithComma() -> Swift.String
}
extension Swift.Double {
  public func formattedString(by format: Swift.String) -> Swift.String
  public var validDateFromTimestamp: Swift.Bool {
    get
  }
  public func elapsedTimeString() -> Swift.String
  public var numberOfDigit: Swift.Int {
    get
  }
  public func elapsedTimeString(with date: Foundation.Date) -> Swift.String
}
public protocol SLRequestable {
  associatedtype Request
  func request(_ request: Self.Request)
}
public enum ImageProcessItem {
  case image(ShopliveSDKCommon.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor {
  var identifier: Swift.String { get }
  func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
extension ShopliveSDKCommon.ImageProcessor {
  public func append(another: ShopliveSDKCommon.ImageProcessor) -> ShopliveSDKCommon.ImageProcessor
}
public struct DefaultImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public static let `default`: ShopliveSDKCommon.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let topLeft: ShopliveSDKCommon.RectCorner
  public static let topRight: ShopliveSDKCommon.RectCorner
  public static let bottomLeft: ShopliveSDKCommon.RectCorner
  public static let bottomRight: ShopliveSDKCommon.RectCorner
  public static let all: ShopliveSDKCommon.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = ShopliveSDKCommon.RectCorner
  public typealias Element = ShopliveSDKCommon.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public enum Radius {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let radius: ShopliveSDKCommon.Radius
  public let roundingCorners: ShopliveSDKCommon.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ShopliveSDKCommon.RectCorner = .all, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil)
  public init(radius: ShopliveSDKCommon.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: ShopliveSDKCommon.RectCorner = .all, backgroundColor: ShopliveSDKCommon.KFCrossPlatformColor? = nil)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct Border {
  public var color: ShopliveSDKCommon.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: ShopliveSDKCommon.Radius
  public var roundingCorners: ShopliveSDKCommon.RectCorner
  public init(color: ShopliveSDKCommon.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: ShopliveSDKCommon.Radius = .point(0), roundingCorners: ShopliveSDKCommon.RectCorner = .all)
}
public struct BorderImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: ShopliveSDKCommon.Border
  public init(border: ShopliveSDKCommon.Border)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public enum ContentMode {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: ShopliveSDKCommon.ContentMode, b: ShopliveSDKCommon.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: ShopliveSDKCommon.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: ShopliveSDKCommon.ContentMode = .none)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct BlurImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: ShopliveSDKCommon.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: ShopliveSDKCommon.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct TintImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let tint: ShopliveSDKCommon.KFCrossPlatformColor
  public init(tint: ShopliveSDKCommon.KFCrossPlatformColor)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : ShopliveSDKCommon.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: ShopliveSDKCommon.ImageProcessor, right: ShopliveSDKCommon.ImageProcessor) -> ShopliveSDKCommon.ImageProcessor
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : ShopliveSDKCommon.ImageProcessor {
  var filter: ShopliveSDKCommon.Filter { get }
}
extension ShopliveSDKCommon.CIImageProcessor {
  public func process(item: ShopliveSDKCommon.ImageProcessItem, options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo) -> ShopliveSDKCommon.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping ShopliveSDKCommon.Transformer)
  public static var tint: (_ color: ShopliveSDKCommon.KFCrossPlatformColor) -> ShopliveSDKCommon.Filter
  public typealias ColorElement = (CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  public static var colorControl: (_ arg: ShopliveSDKCommon.Filter.ColorElement) -> ShopliveSDKCommon.Filter
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: ShopliveSDKCommon.Filter) -> ShopliveSDKCommon.KFCrossPlatformImage
}
extension AVFoundation.AVCaptureDevice {
  public var baseZoomFactor: CoreFoundation.CGFloat {
    get
  }
  public func getInitZoomFactor(forDevice camera: AVFoundation.AVCaptureDevice) -> CoreFoundation.CGFloat
}
extension CoreFoundation.CGRect {
  public var center: CoreFoundation.CGPoint {
    get
  }
}
extension UIKit.UIColor {
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: Swift.Int = 0xFF)
  convenience public init(rgb: Swift.Int)
  convenience public init(argb: Swift.Int)
  convenience public init(_ hex: Swift.String, alpha: CoreFoundation.CGFloat = 1.0)
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImageView {
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with resource: ShopliveSDKCommon.Resource?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with resource: ShopliveSDKCommon.Resource?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with provider: ShopliveSDKCommon.ImageDataProvider?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with provider: ShopliveSDKCommon.ImageDataProvider?, placeholder: ShopliveSDKCommon.Placeholder? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  public func cancelDownloadTask()
}
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : UIKit.UIImageView {
  public var taskIdentifier: ShopliveSDKCommon.Source.Identifier.Value? {
    get
  }
  public var indicatorType: ShopliveSDKCommon.IndicatorType {
    get
    set
  }
  public var indicator: ShopliveSDKCommon.Indicator? {
    get
  }
  public var placeholder: ShopliveSDKCommon.Placeholder? {
    get
  }
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : ShopliveSDKCommon.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : ShopliveSDKCommon.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> ShopliveSDKCommon.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public static let ocsp: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public static let preferCRL: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public static let any: ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public typealias Element = ShopliveSDKCommon.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: ShopliveSDKCommon.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension ShopliveSDKCommon.ServerTrustEvaluating where Self == ShopliveSDKCommon.RevocationTrustEvaluator {
  public static var revocationChecking: ShopliveSDKCommon.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: ShopliveSDKCommon.RevocationTrustEvaluator.Options = .any) -> ShopliveSDKCommon.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension ShopliveSDKCommon.ServerTrustEvaluating where Self == ShopliveSDKCommon.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: ShopliveSDKCommon.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> ShopliveSDKCommon.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension ShopliveSDKCommon.ServerTrustEvaluating where Self == ShopliveSDKCommon.PublicKeysTrustEvaluator {
  public static var publicKeys: ShopliveSDKCommon.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> ShopliveSDKCommon.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public init(evaluators: [ShopliveSDKCommon.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension ShopliveSDKCommon.ServerTrustEvaluating where Self == ShopliveSDKCommon.CompositeTrustEvaluator {
  public static func composite(evaluators: [ShopliveSDKCommon.ServerTrustEvaluating]) -> ShopliveSDKCommon.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = ShopliveSDKCommon.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : ShopliveSDKCommon.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == ShopliveSDKCommon.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: ShopliveSDKCommon.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.Request {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func uploadProgress(bufferingPolicy: ShopliveSDKCommon.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func downloadProgress(bufferingPolicy: ShopliveSDKCommon.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlRequests(bufferingPolicy: ShopliveSDKCommon.StreamOf<Foundation.URLRequest>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.StreamOf<Foundation.URLRequest>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlSessionTasks(bufferingPolicy: ShopliveSDKCommon.StreamOf<Foundation.URLSessionTask>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.StreamOf<Foundation.URLSessionTask>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func cURLDescriptions(bufferingPolicy: ShopliveSDKCommon.StreamOf<Swift.String>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.StreamOf<Swift.String>
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: ShopliveSDKCommon.DataResponse<Value, ShopliveSDKCommon.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, ShopliveSDKCommon.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.DataRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataTask<Value> where Value : Swift.Decodable
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.DataTask<Swift.String>
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> ShopliveSDKCommon.DataTask<Serializer.SerializedObject> where Serializer : ShopliveSDKCommon.ResponseSerializer
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> ShopliveSDKCommon.DataTask<Serializer.SerializedObject> where Serializer : ShopliveSDKCommon.DataResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct AFDownloadTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: ShopliveSDKCommon.DownloadResponse<Value, ShopliveSDKCommon.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, ShopliveSDKCommon.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.DownloadRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.AFDownloadTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: ShopliveSDKCommon.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> ShopliveSDKCommon.AFDownloadTask<Value> where Value : Swift.Decodable
  public func serializingDownloadedFileURL(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> ShopliveSDKCommon.AFDownloadTask<Foundation.URL>
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: ShopliveSDKCommon.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> ShopliveSDKCommon.AFDownloadTask<Swift.String>
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> ShopliveSDKCommon.AFDownloadTask<Serializer.SerializedObject> where Serializer : ShopliveSDKCommon.ResponseSerializer
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> ShopliveSDKCommon.AFDownloadTask<Serializer.SerializedObject> where Serializer : ShopliveSDKCommon.DownloadResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataStreamTask {
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias Stream<Success, Failure> = ShopliveSDKCommon.StreamOf<ShopliveSDKCommon.DataStreamRequest.Stream<Success, Failure>> where Failure : Swift.Error
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: ShopliveSDKCommon.DataStreamTask.Stream<Foundation.Data, Swift.Never>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.DataStreamTask.Stream<Foundation.Data, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingStrings(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: ShopliveSDKCommon.DataStreamTask.Stream<Swift.String, Swift.Never>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.DataStreamTask.Stream<Swift.String, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingDecodables<T>(_ type: T.Type = T.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: ShopliveSDKCommon.DataStreamTask.Stream<T, ShopliveSDKCommon.AFError>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.DataStreamTask.Stream<T, ShopliveSDKCommon.AFError> where T : Swift.Decodable
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingResponses<Serializer>(serializedUsing serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: ShopliveSDKCommon.DataStreamTask.Stream<Serializer.SerializedObject, ShopliveSDKCommon.AFError>.BufferingPolicy = .unbounded) -> ShopliveSDKCommon.DataStreamTask.Stream<Serializer.SerializedObject, ShopliveSDKCommon.AFError> where Serializer : ShopliveSDKCommon.DataStreamSerializer
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.DataStreamRequest {
  final public func streamTask() -> ShopliveSDKCommon.DataStreamTask
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct StreamOf<Element> : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = ShopliveSDKCommon.StreamOf<Element>.Iterator
  public typealias BufferingPolicy = _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy
  public func makeAsyncIterator() -> ShopliveSDKCommon.StreamOf<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> Element?
    #endif
  }
}
#endif
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImage {
  @_hasMissingDesignatedInitializers public class Context<HoldingView> where HoldingView : ShopliveSDKCommon.KFImageHoldingView {
    @objc deinit
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImage.Context : Swift.Hashable {
  public static func == (lhs: ShopliveSDKCommon.KFImage.Context<HoldingView>, rhs: ShopliveSDKCommon.KFImage.Context<HoldingView>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFAnimatedImage {
  public typealias Context = ShopliveSDKCommon.KFImage.Context
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: ShopliveSDKCommon.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: ShopliveSDKCommon.AlamofireExtension<Self.ExtendedType> { get set }
}
extension ShopliveSDKCommon.AlamofireExtended {
  public static var af: ShopliveSDKCommon.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: ShopliveSDKCommon.AlamofireExtension<Self> {
    get
    set
  }
}
public enum ImageTransition {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: ((UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: ((Swift.Bool) -> Swift.Void)?)
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: ShopliveSDKCommon.Request.State, b: ShopliveSDKCommon.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: ShopliveSDKCommon.EventMonitor?
  final public let interceptor: ShopliveSDKCommon.RequestInterceptor?
  weak public var delegate: ShopliveSDKCommon.RequestDelegate? {
    get
  }
  public var state: ShopliveSDKCommon.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: ShopliveSDKCommon.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: ShopliveSDKCommon.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: ShopliveSDKCommon.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping ShopliveSDKCommon.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping ShopliveSDKCommon.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: ShopliveSDKCommon.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: ShopliveSDKCommon.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension ShopliveSDKCommon.Request : Swift.Equatable {
  public static func == (lhs: ShopliveSDKCommon.Request, rhs: ShopliveSDKCommon.Request) -> Swift.Bool
}
extension ShopliveSDKCommon.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ShopliveSDKCommon.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension ShopliveSDKCommon.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: ShopliveSDKCommon.Request)
  func retryResult(for request: ShopliveSDKCommon.Request, dueTo error: ShopliveSDKCommon.AFError, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  func retryRequest(_ request: ShopliveSDKCommon.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : ShopliveSDKCommon.Request {
  final public let convertible: ShopliveSDKCommon.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping ShopliveSDKCommon.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : ShopliveSDKCommon.Request {
  public typealias Handler<Success, Failure> = (ShopliveSDKCommon.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: ShopliveSDKCommon.DataStreamRequest.Event<Success, Failure>
    public let token: ShopliveSDKCommon.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(ShopliveSDKCommon.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: ShopliveSDKCommon.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: ShopliveSDKCommon.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping ShopliveSDKCommon.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension ShopliveSDKCommon.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: ShopliveSDKCommon.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : ShopliveSDKCommon.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: ShopliveSDKCommon.DownloadRequest.Options
    public static let removePreviousFile: ShopliveSDKCommon.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = ShopliveSDKCommon.DownloadRequest.Options
    public typealias Element = ShopliveSDKCommon.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: ShopliveSDKCommon.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: ShopliveSDKCommon.DownloadRequest.Options = []) -> ShopliveSDKCommon.DownloadRequest.Destination
  public enum Downloadable {
    case request(ShopliveSDKCommon.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: ShopliveSDKCommon.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping ShopliveSDKCommon.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : ShopliveSDKCommon.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: ShopliveSDKCommon.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: ShopliveSDKCommon.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> ShopliveSDKCommon.UploadRequest.Uploadable
}
extension ShopliveSDKCommon.UploadRequest.Uploadable : ShopliveSDKCommon.UploadableConvertible {
  public func createUploadable() throws -> ShopliveSDKCommon.UploadRequest.Uploadable
}
public protocol UploadConvertible : ShopliveSDKCommon.URLRequestConvertible, ShopliveSDKCommon.UploadableConvertible {
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class SLTextFieldWithPadding : UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) public init(textPadding: UIKit.UIEdgeInsets)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func textRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func editingRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @objc deinit
}
extension Foundation.NotificationCenter {
  public func safeRemoveObserver(_ observer: Any, name aName: Foundation.NSNotification.Name?, object anObject: Any?)
}
@objc @_Concurrency.MainActor(unsafe) open class SLWSTagView : UIKit.UIView, UIKit.UITextInputTraits {
  @_Concurrency.MainActor(unsafe) open var displayText: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var displayDelimiter: Swift.String {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var font: UIKit.UIFont? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var cornerRadius: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var borderWidth: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var borderColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var selectedColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var textColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var selectedTextColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var selected: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc public var autocapitalizationType: UIKit.UITextAutocapitalizationType
  @_Concurrency.MainActor(unsafe) @objc public var autocorrectionType: UIKit.UITextAutocorrectionType
  @_Concurrency.MainActor(unsafe) @objc public var spellCheckingType: UIKit.UITextSpellCheckingType
  @_Concurrency.MainActor(unsafe) @objc public var keyboardType: UIKit.UIKeyboardType
  @_Concurrency.MainActor(unsafe) @objc public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @_Concurrency.MainActor(unsafe) @objc public var returnKeyType: UIKit.UIReturnKeyType
  @_Concurrency.MainActor(unsafe) @objc public var enablesReturnKeyAutomatically: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public var isSecureTextEntry: Swift.Bool
  @_Concurrency.MainActor(unsafe) public init(tag: ShopliveSDKCommon.SLWSTag)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) open func sizeToFit(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func becomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func resignFirstResponder() -> Swift.Bool
  @objc deinit
}
extension ShopliveSDKCommon.SLWSTagView : UIKit.UIKeyInput {
  @_Concurrency.MainActor(unsafe) @objc dynamic public var hasText: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc dynamic public func insertText(_ text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func deleteBackward()
}
extension Foundation.URLSessionConfiguration : ShopliveSDKCommon.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension ShopliveSDKCommon.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [ShopliveSDKCommon.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: ShopliveSDKCommon.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: ShopliveSDKCommon.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> ShopliveSDKCommon.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension ShopliveSDKCommon.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension ShopliveSDKCommon.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: ShopliveSDKCommon.HTTPHeader...)
  public typealias ArrayLiteralElement = ShopliveSDKCommon.HTTPHeader
}
extension ShopliveSDKCommon.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[ShopliveSDKCommon.HTTPHeader]>
}
extension ShopliveSDKCommon.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> ShopliveSDKCommon.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = ShopliveSDKCommon.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<ShopliveSDKCommon.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[ShopliveSDKCommon.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<ShopliveSDKCommon.HTTPHeaders>
}
extension ShopliveSDKCommon.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: ShopliveSDKCommon.HTTPHeader, b: ShopliveSDKCommon.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension ShopliveSDKCommon.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension ShopliveSDKCommon.HTTPHeader {
  public static func accept(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func authorization(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func contentEncoding(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func contentType(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> ShopliveSDKCommon.HTTPHeader
}
extension ShopliveSDKCommon.HTTPHeaders {
  public static let `default`: ShopliveSDKCommon.HTTPHeaders
}
extension ShopliveSDKCommon.HTTPHeader {
  public static let defaultAcceptEncoding: ShopliveSDKCommon.HTTPHeader
  public static let defaultAcceptLanguage: ShopliveSDKCommon.HTTPHeader
  public static let defaultUserAgent: ShopliveSDKCommon.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: ShopliveSDKCommon.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: ShopliveSDKCommon.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: ShopliveSDKCommon.HTTPHeaders {
    get
    set
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class SLBackspaceDetectingTextField : UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) open var onDeleteBackwards: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func deleteBackward()
  @objc deinit
}
public enum MemoryStorage {
  public class Backend<T> where T : ShopliveSDKCommon.CacheCostCalculable {
    public var config: ShopliveSDKCommon.MemoryStorage.Config {
      get
      set
    }
    public init(config: ShopliveSDKCommon.MemoryStorage.Config)
    public func removeExpired()
    public func store(value: T, forKey key: Swift.String, expiration: ShopliveSDKCommon.StorageExpiration? = nil)
    public func value(forKey key: Swift.String, extendingExpiration: ShopliveSDKCommon.ExpirationExtending = .cacheTime) -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension ShopliveSDKCommon.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: ShopliveSDKCommon.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
@available(iOS 14.0, *)
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : CarPlay.CPListItem {
  @discardableResult
  public func setImage(with source: ShopliveSDKCommon.Source?, placeholder: ShopliveSDKCommon.KFCrossPlatformImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setImage(with resource: ShopliveSDKCommon.Resource?, placeholder: ShopliveSDKCommon.KFCrossPlatformImage? = nil, options: ShopliveSDKCommon.SLKingfisherOptionsInfo? = nil, progressBlock: ShopliveSDKCommon.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<ShopliveSDKCommon.RetrieveImageResult, ShopliveSDKCommon.SLKingfisherError>) -> Swift.Void)? = nil) -> ShopliveSDKCommon.SLDownloadTask?
  public func cancelDownloadTask()
}
@available(iOS 12.0, *)
extension ShopliveSDKCommon.SLKingfisherWrapper where Base : CarPlay.CPListItem {
  public var taskIdentifier: ShopliveSDKCommon.Source.Identifier.Value? {
    get
  }
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: ShopliveSDKCommon.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: ShopliveSDKCommon.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
extension ShopliveSDKCommon.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: ShopliveSDKCommon.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : ShopliveSDKCommon.RequestAdapter, ShopliveSDKCommon.RequestRetrier {
}
extension ShopliveSDKCommon.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, ShopliveSDKCommon.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (ShopliveSDKCommon.Request, ShopliveSDKCommon.Session, Swift.Error, _ completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : ShopliveSDKCommon.RequestInterceptor {
  public init(_ adaptHandler: @escaping ShopliveSDKCommon.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: ShopliveSDKCommon.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension ShopliveSDKCommon.RequestAdapter where Self == ShopliveSDKCommon.Adapter {
  public static func adapter(using closure: @escaping ShopliveSDKCommon.AdaptHandler) -> ShopliveSDKCommon.Adapter
}
open class Retrier : ShopliveSDKCommon.RequestInterceptor {
  public init(_ retryHandler: @escaping ShopliveSDKCommon.RetryHandler)
  open func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  @objc deinit
}
extension ShopliveSDKCommon.RequestRetrier where Self == ShopliveSDKCommon.Retrier {
  public static func retrier(using closure: @escaping ShopliveSDKCommon.RetryHandler) -> ShopliveSDKCommon.Retrier
}
open class Interceptor : ShopliveSDKCommon.RequestInterceptor {
  final public let adapters: [ShopliveSDKCommon.RequestAdapter]
  final public let retriers: [ShopliveSDKCommon.RequestRetrier]
  public init(adaptHandler: @escaping ShopliveSDKCommon.AdaptHandler, retryHandler: @escaping ShopliveSDKCommon.RetryHandler)
  public init(adapter: ShopliveSDKCommon.RequestAdapter, retrier: ShopliveSDKCommon.RequestRetrier)
  public init(adapters: [ShopliveSDKCommon.RequestAdapter] = [], retriers: [ShopliveSDKCommon.RequestRetrier] = [], interceptors: [ShopliveSDKCommon.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: ShopliveSDKCommon.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: ShopliveSDKCommon.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  @objc deinit
}
extension ShopliveSDKCommon.RequestInterceptor where Self == ShopliveSDKCommon.Interceptor {
  public static func interceptor(adapter: @escaping ShopliveSDKCommon.AdaptHandler, retrier: @escaping ShopliveSDKCommon.RetryHandler) -> ShopliveSDKCommon.Interceptor
  public static func interceptor(adapter: ShopliveSDKCommon.RequestAdapter, retrier: ShopliveSDKCommon.RequestRetrier) -> ShopliveSDKCommon.Interceptor
  public static func interceptor(adapters: [ShopliveSDKCommon.RequestAdapter] = [], retriers: [ShopliveSDKCommon.RequestRetrier] = [], interceptors: [ShopliveSDKCommon.RequestInterceptor] = []) -> ShopliveSDKCommon.Interceptor
}
@objc public enum PermissionType : Swift.Int {
  case camera
  case microphone
  case idfa
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum PermissionStatus : Swift.Int {
  case authorized
  case denied
  case notDetermined
  case notSupported
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum PermissionError : Swift.Error {
  case denied
  case notSupported
  public static func == (a: ShopliveSDKCommon.PermissionError, b: ShopliveSDKCommon.PermissionError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class PermissionManager : ShopliveSDKCommon.SLRequestable, ShopliveSDKCommon.SLResultObservable {
  public enum Request {
    case checkEveryPermission
    public static func == (a: ShopliveSDKCommon.PermissionManager.Request, b: ShopliveSDKCommon.PermissionManager.Request) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Result {
    case authorizationResult(camera: ShopliveSDKCommon.PermissionStatus, audio: ShopliveSDKCommon.PermissionStatus)
  }
  final public func request(_ request: ShopliveSDKCommon.PermissionManager.Request)
  public init()
  final public var resultHandler: ((ShopliveSDKCommon.PermissionManager.Result) -> ())?
  final public var deviceAuthorized: Swift.Bool {
    get
  }
  final public var deviceChecked: Swift.Bool {
    get
  }
  final public var cameraAuthorized: Swift.Bool {
    get
  }
  final public var audioAuthorized: Swift.Bool {
    get
  }
  @objc deinit
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func setBackgroundColor(_ color: UIKit.UIColor, for state: UIKit.UIControl.State)
}
public struct SLWSTag : Swift.Hashable {
  public let text: Swift.String
  public let context: Swift.AnyHashable?
  public init(_ text: Swift.String, context: Swift.AnyHashable? = nil)
  public func equals(_ other: ShopliveSDKCommon.SLWSTag) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: ShopliveSDKCommon.SLWSTag, rhs: ShopliveSDKCommon.SLWSTag) -> Swift.Bool
open class RetryPolicy : ShopliveSDKCommon.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: ShopliveSDKCommon.Request, for session: ShopliveSDKCommon.Session, dueTo error: Swift.Error, completion: @escaping (ShopliveSDKCommon.RetryResult) -> Swift.Void)
  open func shouldRetry(request: ShopliveSDKCommon.Request, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
extension ShopliveSDKCommon.RequestInterceptor where Self == ShopliveSDKCommon.RetryPolicy {
  public static var retryPolicy: ShopliveSDKCommon.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> ShopliveSDKCommon.RetryPolicy
}
open class ConnectionLostRetryPolicy : ShopliveSDKCommon.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension ShopliveSDKCommon.RequestInterceptor where Self == ShopliveSDKCommon.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: ShopliveSDKCommon.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<ShopliveSDKCommon.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> ShopliveSDKCommon.ConnectionLostRetryPolicy
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImageProtocol {
  public static func source(_ source: ShopliveSDKCommon.Source?) -> Self
  public static func resource(_ resource: ShopliveSDKCommon.Resource?) -> Self
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> Self
  public static func dataProvider(_ provider: ShopliveSDKCommon.ImageDataProvider?) -> Self
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> Self
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension ShopliveSDKCommon.KFImageProtocol {
  public func placeholder<P>(@SwiftUI.ViewBuilder _ content: @escaping (Foundation.Progress) -> P) -> Self where P : SwiftUI.View
  public func placeholder<P>(@SwiftUI.ViewBuilder _ content: @escaping () -> P) -> Self where P : SwiftUI.View
  public func cancelOnDisappear(_ flag: Swift.Bool) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func startLoadingBeforeViewAppear(_ flag: Swift.Bool = true) -> Self
}
@_hasMissingDesignatedInitializers final public class URLUtil {
  public static func query(_ params: [Foundation.URLQueryItem]?) -> Swift.String?
  @objc deinit
}
extension Foundation.NSAttributedString {
  public var fullRange: Foundation.NSRange {
    get
  }
}
extension Foundation.URLRequest {
  public var method: ShopliveSDKCommon.HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
open class KeychainWrapper {
  @available(*, deprecated, message: "KeychainWrapper.defaultKeychainWrapper is deprecated since version 2.2.1, use KeychainWrapper.standard instead")
  public static let defaultKeychainWrapper: ShopliveSDKCommon.KeychainWrapper
  public static let standard: ShopliveSDKCommon.KeychainWrapper
  public var serviceName: Swift.String {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public init(serviceName: Swift.String, accessGroup: Swift.String? = nil)
  open func hasValue(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  open func accessibilityOfKey(_ key: Swift.String) -> ShopliveSDKCommon.KeychainItemAccessibility?
  open func allKeys() -> Swift.Set<Swift.String>
  open func integer(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Int?
  open func float(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Float?
  open func double(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Double?
  open func bool(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool?
  open func string(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.String?
  open func object<T>(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false, ofClass: T.Type) -> T? where T : ObjectiveC.NSObject, T : Foundation.NSCoding
  open func data(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  open func dataRef(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Foundation.Data?
  @discardableResult
  open func set(_ value: Swift.Int, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Float, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Double, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.NSCoding, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @available(*, deprecated, message: "remove is deprecated since version 2.2.1, use removeObject instead")
  @discardableResult
  open func remove(key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeObject(forKey key: Swift.String, withAccessibility accessibility: ShopliveSDKCommon.KeychainItemAccessibility? = nil, isSynchronizable: Swift.Bool = false) -> Swift.Bool
  @discardableResult
  open func removeAllKeys() -> Swift.Bool
  open class func wipeKeychain()
  @objc deinit
}
public enum KF {
  public static func source(_ source: ShopliveSDKCommon.Source?) -> ShopliveSDKCommon.KF.Builder
  public static func resource(_ resource: ShopliveSDKCommon.Resource?) -> ShopliveSDKCommon.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> ShopliveSDKCommon.KF.Builder
  public static func dataProvider(_ provider: ShopliveSDKCommon.ImageDataProvider?) -> ShopliveSDKCommon.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> ShopliveSDKCommon.KF.Builder
}
extension ShopliveSDKCommon.KF {
  @_hasMissingDesignatedInitializers public class Builder {
    public var options: ShopliveSDKCommon.SLKingfisherParsedOptionsInfo
    final public let onFailureDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.SLKingfisherError, Swift.Void>
    final public let onSuccessDelegate: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: ShopliveSDKCommon.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
extension ShopliveSDKCommon.KF.Builder {
  @discardableResult
  public func set(to imageView: ShopliveSDKCommon.KFCrossPlatformImageView) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping () -> ShopliveSDKCommon.KFCrossPlatformView) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> ShopliveSDKCommon.SLDownloadTask?
  @discardableResult
  public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> ShopliveSDKCommon.SLDownloadTask?
  @available(iOS 14.0, *)
  @discardableResult
  public func set(to listItem: CarPlay.CPListItem) -> ShopliveSDKCommon.SLDownloadTask?
}
extension ShopliveSDKCommon.KF.Builder {
  public func placeholder(_ placeholder: ShopliveSDKCommon.Placeholder?) -> Self
  public func placeholder(_ image: ShopliveSDKCommon.KFCrossPlatformImage?) -> Self
}
extension ShopliveSDKCommon.KF.Builder {
  public func transition(_ transition: ShopliveSDKCommon.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  public func progressiveJPEG(_ progressive: ShopliveSDKCommon.ImageProgressive? = .init()) -> Self
}
extension ShopliveSDKCommon.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension ShopliveSDKCommon.KF {
  public struct RedirectPayload {
    public let task: ShopliveSDKCommon.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
public struct SLWSTagAcceptOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let `return`: ShopliveSDKCommon.SLWSTagAcceptOption
  public static let comma: ShopliveSDKCommon.SLWSTagAcceptOption
  public static let space: ShopliveSDKCommon.SLWSTagAcceptOption
  public typealias ArrayLiteralElement = ShopliveSDKCommon.SLWSTagAcceptOption
  public typealias Element = ShopliveSDKCommon.SLWSTagAcceptOption
  public typealias RawValue = Swift.Int
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) open class SLWSTagsField : UIKit.UIScrollView {
  @_Concurrency.MainActor(unsafe) final public let textField: ShopliveSDKCommon.SLBackspaceDetectingTextField
  @_Concurrency.MainActor(unsafe) weak open var textDelegate: UIKit.UITextFieldDelegate?
  @IBInspectable @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var textColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var selectedColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var selectedTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var delimiter: Swift.String {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var isDelimiterVisible: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var shouldTokenizeAfterResigningFirstResponder: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var maxHeight: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var numberOfLines: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var enableScrolling: Swift.Bool
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var cornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var borderWidth: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var borderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var layoutMargins: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "use 'textField.textColor' directly.")
  @_Concurrency.MainActor(unsafe) open var fieldTextColor: UIKit.UIColor? {
    get
    set
  }
  @available(iOS 10.0, *)
  @available(*, deprecated, message: "use 'textField.fieldTextContentType' directly.")
  @_Concurrency.MainActor(unsafe) open var fieldTextContentType: UIKit.UITextContentType! {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholder: Swift.String {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderAlwaysVisible: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var font: UIKit.UIFont? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) open var keyboardAppearance: UIKit.UIKeyboardAppearance {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var readOnly: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var acceptTagOption: ShopliveSDKCommon.SLWSTagAcceptOption
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var contentInset: UIKit.UIEdgeInsets {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var spaceBetweenTags: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var spaceBetweenLines: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isFirstResponder: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) open var tags: [ShopliveSDKCommon.SLWSTag] {
    get
  }
  @_Concurrency.MainActor(unsafe) open var tagViews: [ShopliveSDKCommon.SLWSTagView]
  @_Concurrency.MainActor(unsafe) open var onShouldAcceptTag: ((ShopliveSDKCommon.SLWSTagsField) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) open var onDidChangeText: ((ShopliveSDKCommon.SLWSTagsField, _ text: Swift.String?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onDidAddTag: ((ShopliveSDKCommon.SLWSTagsField, _ tag: ShopliveSDKCommon.SLWSTag) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onDidRemoveTag: ((ShopliveSDKCommon.SLWSTagsField, _ tag: ShopliveSDKCommon.SLWSTag) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onDidSelectTagView: ((ShopliveSDKCommon.SLWSTagsField, _ tag: ShopliveSDKCommon.SLWSTagView) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onDidUnselectTagView: ((ShopliveSDKCommon.SLWSTagsField, _ tag: ShopliveSDKCommon.SLWSTagView) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var onValidateTag: ((ShopliveSDKCommon.SLWSTag, [ShopliveSDKCommon.SLWSTag]) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) open var onVerifyTag: ((ShopliveSDKCommon.SLWSTagsField, _ text: Swift.String) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) open var onDidChangeHeightTo: ((ShopliveSDKCommon.SLWSTagsField, _ height: CoreFoundation.CGFloat) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var useCloseButton: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var preferredMaxLayoutWidth: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) open var suggestions: [Swift.String]
  @_Concurrency.MainActor(unsafe) open var caseSensitiveSuggestions: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func willMove(toSuperview newSuperview: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) open func setCornerRadius(to cornerRadius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) open func acceptCurrentTextAsTag()
  @_Concurrency.MainActor(unsafe) open var isEditing: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open func beginEditing()
  @_Concurrency.MainActor(unsafe) open func endEditing()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func reloadInputViews()
  @_Concurrency.MainActor(unsafe) open func addTags(_ tags: [Swift.String])
  @_Concurrency.MainActor(unsafe) open func addTags(_ tags: [ShopliveSDKCommon.SLWSTag])
  @_Concurrency.MainActor(unsafe) open func addTag(_ tag: Swift.String)
  @_Concurrency.MainActor(unsafe) open func addTag(_ tag: ShopliveSDKCommon.SLWSTag)
  @_Concurrency.MainActor(unsafe) open func removeTag(_ tag: Swift.String)
  @_Concurrency.MainActor(unsafe) open func removeTag(_ tag: ShopliveSDKCommon.SLWSTag)
  @_Concurrency.MainActor(unsafe) open func removeTagAtIndex(_ index: Swift.Int)
  @_Concurrency.MainActor(unsafe) open func removeTags()
  @discardableResult
  @_Concurrency.MainActor(unsafe) open func tokenizeTextFieldText() -> ShopliveSDKCommon.SLWSTag?
  @objc @_Concurrency.MainActor(unsafe) open func onTextFieldDidChange(_ sender: Swift.AnyObject)
  @_Concurrency.MainActor(unsafe) open func selectNextTag()
  @_Concurrency.MainActor(unsafe) open func selectPrevTag()
  @_Concurrency.MainActor(unsafe) open func selectTagView(_ tagView: ShopliveSDKCommon.SLWSTagView, animated: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) open func unselectAllTagViewsAnimated(_ animated: Swift.Bool = false)
}
extension ShopliveSDKCommon.SLWSTagsField {
  @available(*, deprecated, message: "use 'textField.keyboardType' directly.")
  @_Concurrency.MainActor(unsafe) public var keyboardType: UIKit.UIKeyboardType {
    get
    set
  }
  @available(*, deprecated, message: "use 'textField.returnKeyType' directly.")
  @_Concurrency.MainActor(unsafe) public var returnKeyType: UIKit.UIReturnKeyType {
    get
    set
  }
  @available(*, deprecated, message: "use 'textField.spellCheckingType' directly.")
  @_Concurrency.MainActor(unsafe) public var spellCheckingType: UIKit.UITextSpellCheckingType {
    get
    set
  }
  @available(*, deprecated, message: "use 'textField.autocapitalizationType' directly.")
  @_Concurrency.MainActor(unsafe) public var autocapitalizationType: UIKit.UITextAutocapitalizationType {
    get
    set
  }
  @available(*, deprecated, message: "use 'textField.autocorrectionType' directly.")
  @_Concurrency.MainActor(unsafe) public var autocorrectionType: UIKit.UITextAutocorrectionType {
    get
    set
  }
  @available(*, deprecated, message: "use 'textField.enablesReturnKeyAutomatically' directly.")
  @_Concurrency.MainActor(unsafe) public var enablesReturnKeyAutomatically: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var text: Swift.String? {
    get
    set
  }
  @available(*, deprecated, message: "Use 'inputFieldAccessoryView' instead")
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var inputAccessoryView: UIKit.UIView? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) open var inputFieldAccessoryView: UIKit.UIView? {
    get
    set
  }
}
extension ShopliveSDKCommon.SLWSTagsField : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
extension ShopliveSDKCommon.SLWSTagsField {
  @_Concurrency.MainActor(unsafe) public static func == (lhs: UIKit.UITextField, rhs: ShopliveSDKCommon.SLWSTagsField) -> Swift.Bool
}
public enum NVActivityIndicatorType : Swift.CaseIterable {
  case blank
  case ballPulse
  case ballGridPulse
  case ballClipRotate
  case squareSpin
  case ballClipRotatePulse
  case ballClipRotateMultiple
  case ballPulseRise
  case ballRotate
  case cubeTransition
  case ballZigZag
  case ballZigZagDeflect
  case ballTrianglePath
  case ballScale
  case lineScale
  case lineScaleParty
  case ballScaleMultiple
  case ballPulseSync
  case ballBeat
  case ballDoubleBounce
  case lineScalePulseOut
  case lineScalePulseOutRapid
  case ballScaleRipple
  case ballScaleRippleMultiple
  case ballSpinFadeLoader
  case lineSpinFadeLoader
  case triangleSkewSpin
  case pacman
  case ballGridBeat
  case semiCircleSpin
  case ballRotateChase
  case orbit
  case audioEqualizer
  case circleStrokeSpin
  public static func == (a: ShopliveSDKCommon.NVActivityIndicatorType, b: ShopliveSDKCommon.NVActivityIndicatorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [ShopliveSDKCommon.NVActivityIndicatorType]
  public static var allCases: [ShopliveSDKCommon.NVActivityIndicatorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias FadeInAnimation = (UIKit.UIView) -> Swift.Void
public typealias FadeOutAnimation = (UIKit.UIView, @escaping () -> Swift.Void) -> Swift.Void
@objc @_Concurrency.MainActor(unsafe) final public class SLSLNVActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TYPE: ShopliveSDKCommon.NVActivityIndicatorType
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TEXT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_PADDING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_SIZE: CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_DISPLAY_TIME_THRESHOLD: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MINIMUM_DISPLAY_TIME: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE: Swift.String?
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_SPACING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_FONT: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_BACKGROUND_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_IN_ANIMATION: (_ view: UIKit.UIView) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_OUT_ANIMATION: (_ view: UIKit.UIView, _ complete: @escaping () -> Swift.Void) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var type: ShopliveSDKCommon.NVActivityIndicatorType
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var color: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var padding: CoreFoundation.CGFloat
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) final public var animating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, type: ShopliveSDKCommon.NVActivityIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func startAnimating()
  @_Concurrency.MainActor(unsafe) final public func stopAnimating()
  @objc deinit
}
public protocol Resource {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension ShopliveSDKCommon.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> ShopliveSDKCommon.Source
}
public struct ImageResource : ShopliveSDKCommon.Resource {
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public let cacheKey: Swift.String
  public let downloadURL: Foundation.URL
}
extension Foundation.URL : ShopliveSDKCommon.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
extension CoreFoundation.CGFloat {
  public var toInt: Swift.Int {
    get
  }
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : ShopliveSDKCommon.ParameterEncoder {
  public static var `default`: ShopliveSDKCommon.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: ShopliveSDKCommon.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: ShopliveSDKCommon.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension ShopliveSDKCommon.ParameterEncoder where Self == ShopliveSDKCommon.JSONParameterEncoder {
  public static var json: ShopliveSDKCommon.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> ShopliveSDKCommon.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : ShopliveSDKCommon.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination, b: ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: ShopliveSDKCommon.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: ShopliveSDKCommon.URLEncodedFormEncoder
  final public let destination: ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination
  public init(encoder: ShopliveSDKCommon.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension ShopliveSDKCommon.ParameterEncoder where Self == ShopliveSDKCommon.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: ShopliveSDKCommon.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: ShopliveSDKCommon.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> ShopliveSDKCommon.URLEncodedFormParameterEncoder
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct KFAnimatedImage : ShopliveSDKCommon.KFImageProtocol {
  public typealias HoldingView = ShopliveSDKCommon.KFAnimatedImageViewRepresenter
  public var context: ShopliveSDKCommon.KFImage.Context<ShopliveSDKCommon.KFAnimatedImage.HoldingView>
  public init(context: ShopliveSDKCommon.KFImage.Context<ShopliveSDKCommon.KFAnimatedImage.HoldingView>)
  public func configure(_ block: @escaping (ShopliveSDKCommon.KFAnimatedImage.HoldingView.RenderingView) -> Swift.Void) -> ShopliveSDKCommon.KFAnimatedImage
  public typealias Body = @_opaqueReturnTypeOf("$s17ShopliveSDKCommon15KFImageProtocolPAAE4bodyQrvp", 0) __<ShopliveSDKCommon.KFAnimatedImage>
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
public struct KFAnimatedImageViewRepresenter : SwiftUI.UIViewRepresentable, ShopliveSDKCommon.KFImageHoldingView {
  public typealias RenderingView = ShopliveSDKCommon.AnimatedImageView
  public static func created(from image: ShopliveSDKCommon.KFCrossPlatformImage?, context: ShopliveSDKCommon.KFImage.Context<ShopliveSDKCommon.KFAnimatedImageViewRepresenter>) -> ShopliveSDKCommon.KFAnimatedImageViewRepresenter
  @_Concurrency.MainActor(unsafe) public func makeUIView(context: ShopliveSDKCommon.KFAnimatedImageViewRepresenter.Context) -> ShopliveSDKCommon.AnimatedImageView
  @_Concurrency.MainActor(unsafe) public func updateUIView(_ uiView: ShopliveSDKCommon.AnimatedImageView, context: ShopliveSDKCommon.KFAnimatedImageViewRepresenter.Context)
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = ShopliveSDKCommon.AnimatedImageView
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity
  case image(imageData: Foundation.Data)
  case custom(indicator: ShopliveSDKCommon.Indicator)
}
public protocol Indicator {
  func startAnimatingView()
  func stopAnimatingView()
  var centerOffset: CoreFoundation.CGPoint { get }
  var view: ShopliveSDKCommon.IndicatorView { get }
  func sizeStrategy(in imageView: ShopliveSDKCommon.KFCrossPlatformImageView) -> ShopliveSDKCommon.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension ShopliveSDKCommon.Indicator {
  public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  public func sizeStrategy(in imageView: ShopliveSDKCommon.KFCrossPlatformImageView) -> ShopliveSDKCommon.IndicatorSizeStrategy
}
public protocol Then {
}
extension ShopliveSDKCommon.Then {
  @inlinable public func `do`(_ block: (Self) throws -> Swift.Void) rethrows {
    try block(self)
  }
}
extension ObjectiveC.NSObject : ShopliveSDKCommon.Then {
}
extension Swift.Array : ShopliveSDKCommon.Then {
}
extension Swift.Dictionary : ShopliveSDKCommon.Then {
}
extension Swift.Set : ShopliveSDKCommon.Then {
}
extension Foundation.JSONDecoder : ShopliveSDKCommon.Then {
}
extension Foundation.JSONEncoder : ShopliveSDKCommon.Then {
}
public typealias ExecutionQueue = ShopliveSDKCommon.CallbackQueue
public enum CallbackQueue {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping () -> Swift.Void)
}
public enum Source {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(ShopliveSDKCommon.Resource)
  case provider(ShopliveSDKCommon.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension ShopliveSDKCommon.Source : Swift.Hashable {
  public static func == (lhs: ShopliveSDKCommon.Source, rhs: ShopliveSDKCommon.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = ShopliveSDKCommon.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  func downloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: ShopliveSDKCommon.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension ShopliveSDKCommon.AuthenticationChallengeResponsible {
  public func downloader(_ downloader: ShopliveSDKCommon.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: ShopliveSDKCommon.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
public class Delegate<Input, Output> {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  @objc deinit
}
extension ShopliveSDKCommon.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension ShopliveSDKCommon.Delegate where Input == (), Output : ShopliveSDKCommon.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension ShopliveSDKCommon.Delegate where Output : ShopliveSDKCommon.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
extension Swift.Optional : ShopliveSDKCommon.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
public struct ImageProgressive {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(ShopliveSDKCommon.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax symatic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: ShopliveSDKCommon.ImageProgressive
  public let onImageUpdated: ShopliveSDKCommon.Delegate<ShopliveSDKCommon.KFCrossPlatformImage, ShopliveSDKCommon.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
extension UIKit.UIDeviceOrientation {
  public var interfaceOrientation: UIKit.UIInterfaceOrientation {
    get
  }
  public var orientationMask: UIKit.UIInterfaceOrientationMask {
    get
  }
}
extension ShopliveSDKCommon.URLEncoding.Destination : Swift.Equatable {}
extension ShopliveSDKCommon.URLEncoding.Destination : Swift.Hashable {}
extension ShopliveSDKCommon.URLEncoding.BoolEncoding : Swift.Equatable {}
extension ShopliveSDKCommon.URLEncoding.BoolEncoding : Swift.Hashable {}
extension ShopliveSDKCommon.JSONEncoding.Error : Swift.Equatable {}
extension ShopliveSDKCommon.JSONEncoding.Error : Swift.Hashable {}
extension ShopliveSDKCommon.ImageFormat : Swift.Equatable {}
extension ShopliveSDKCommon.ImageFormat : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension ShopliveSDKCommon.SLReachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension ShopliveSDKCommon.SLReachability.NetworkStatus : Swift.Hashable {}
extension ShopliveSDKCommon.SLReachability.Connection : Swift.Equatable {}
extension ShopliveSDKCommon.SLReachability.Connection : Swift.Hashable {}
extension ShopliveSDKCommon.AuthenticationError : Swift.Equatable {}
extension ShopliveSDKCommon.AuthenticationError : Swift.Hashable {}
extension ShopliveSDKCommon.SLToastDuration : Swift.Equatable {}
extension ShopliveSDKCommon.SLToastDuration : Swift.Hashable {}
extension ShopliveSDKCommon.ShopliveErrorType : Swift.Equatable {}
extension ShopliveSDKCommon.ShopliveErrorType : Swift.Hashable {}
extension ShopliveSDKCommon.ShopliveErrorType : Swift.RawRepresentable {}
extension UIKit.UIImage.Quality : Swift.Equatable {}
extension UIKit.UIImage.Quality : Swift.Hashable {}
extension UIKit.UIView.ViewSide : Swift.Equatable {}
extension UIKit.UIView.ViewSide : Swift.Hashable {}
extension ShopliveSDKCommon.NetworkMonitor.ConnectionType : Swift.Equatable {}
extension ShopliveSDKCommon.NetworkMonitor.ConnectionType : Swift.Hashable {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Equatable {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension ShopliveSDKCommon.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Hashable {}
extension ShopliveSDKCommon.PanDirection : Swift.Equatable {}
extension ShopliveSDKCommon.PanDirection : Swift.Hashable {}
extension ShopliveSDKCommon.PanDirection : Swift.RawRepresentable {}
extension ShopliveSDKCommon.CacheType : Swift.Equatable {}
extension ShopliveSDKCommon.CacheType : Swift.Hashable {}
extension ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension ShopliveSDKCommon.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension ShopliveSDKCommon.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension ShopliveSDKCommon.HTTPVersion : Swift.Equatable {}
extension ShopliveSDKCommon.HTTPVersion : Swift.Hashable {}
extension ShopliveSDKCommon.HTTPVersion : Swift.RawRepresentable {}
extension ShopliveSDKCommon.SLHTTPMethod : Swift.Equatable {}
extension ShopliveSDKCommon.SLHTTPMethod : Swift.Hashable {}
extension ShopliveSDKCommon.KeychainItemAccessibility : Swift.Equatable {}
extension ShopliveSDKCommon.KeychainItemAccessibility : Swift.Hashable {}
extension ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension ShopliveSDKCommon.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension ShopliveSDKCommon.ContentMode : Swift.Equatable {}
extension ShopliveSDKCommon.ContentMode : Swift.Hashable {}
extension ShopliveSDKCommon.Request.State : Swift.Equatable {}
extension ShopliveSDKCommon.Request.State : Swift.Hashable {}
extension ShopliveSDKCommon.PermissionType : Swift.Equatable {}
extension ShopliveSDKCommon.PermissionType : Swift.Hashable {}
extension ShopliveSDKCommon.PermissionType : Swift.RawRepresentable {}
extension ShopliveSDKCommon.PermissionStatus : Swift.Equatable {}
extension ShopliveSDKCommon.PermissionStatus : Swift.Hashable {}
extension ShopliveSDKCommon.PermissionStatus : Swift.RawRepresentable {}
extension ShopliveSDKCommon.PermissionError : Swift.Equatable {}
extension ShopliveSDKCommon.PermissionError : Swift.Hashable {}
extension ShopliveSDKCommon.PermissionManager.Request : Swift.Equatable {}
extension ShopliveSDKCommon.PermissionManager.Request : Swift.Hashable {}
extension ShopliveSDKCommon.NVActivityIndicatorType : Swift.Equatable {}
extension ShopliveSDKCommon.NVActivityIndicatorType : Swift.Hashable {}
extension ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension ShopliveSDKCommon.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
